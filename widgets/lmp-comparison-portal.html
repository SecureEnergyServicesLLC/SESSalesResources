<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Energy Cost Modeling and Comparison Tool - Secure Energy</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0d9488 0%, #065f46 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: #1f2937;
            margin-bottom: 30px;
            background: white;
            padding: 40px;
            border-radius: 16px;
            position: relative;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.9),
                inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        }

        .header::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            right: -6px;
            bottom: -6px;
            background: linear-gradient(135deg, #0d9488 0%, #065f46 50%, #0d9488 100%);
            border-radius: 18px;
            z-index: -1;
            box-shadow: 
                0 0 0 2px rgba(255, 255, 255, 0.1),
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
        }

        .header-logo {
            max-width: 40%;
            width: 40%;
            height: auto;
            margin: 0 auto 20px auto;
            display: block;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
            font-weight: 700;
            color: #065f46;
        }

        .header p {
            font-size: 18px;
            color: #4b5563;
            line-height: 1.6;
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 20px;
            position: relative;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.9),
                inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        }

        .card::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            right: -6px;
            bottom: -6px;
            background: linear-gradient(135deg, #0d9488 0%, #065f46 50%, #0d9488 100%);
            border-radius: 18px;
            z-index: -1;
            box-shadow: 
                0 0 0 2px rgba(255, 255, 255, 0.1),
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
        }

        .section-title {
            font-size: 22px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 25px;
            padding-bottom: 12px;
            border-bottom: 3px solid #0d9488;
        }

        .section-subtitle {
            font-size: 16px;
            font-weight: 600;
            color: #0d9488;
            margin: 20px 0 15px 0;
            padding-left: 10px;
            border-left: 4px solid #0d9488;
        }

        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-size: 13px;
            font-weight: 600;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-field {
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .input-field:focus {
            outline: none;
            border-color: #0d9488;
            box-shadow: 0 0 0 3px rgba(13, 148, 136, 0.1);
        }

        .term-info-box {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border: 3px solid #10b981;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .term-info-box h3 {
            color: #065f46;
            font-size: 18px;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .term-info-content {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .term-info-item {
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .term-info-label {
            font-size: 11px;
            color: #6b7280;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .term-info-value {
            font-size: 20px;
            color: #065f46;
            font-weight: 700;
        }

        .projection-notice {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border: 3px solid #f59e0b;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        .projection-notice h3 {
            color: #92400e;
            font-size: 16px;
            margin-bottom: 10px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .projection-notice p {
            color: #78350f;
            line-height: 1.6;
            font-size: 14px;
        }

        .projected-badge {
            display: inline-block;
            background: #fbbf24;
            color: #78350f;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            margin-left: 5px;
            letter-spacing: 0.5px;
        }

        .slider-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #0d9488;
            position: relative;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .slider-label span {
            font-weight: 600;
            color: #0d9488;
        }

        .slider-value {
            font-size: 20px;
            font-weight: 700;
            color: #065f46;
        }

        .slider-wrapper {
            position: relative;
            padding: 10px 0;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #fee2e2, #fef3c7, #d1fae5);
            outline: none;
            -webkit-appearance: none;
            position: relative;
            z-index: 2;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #0d9488;
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #0d9488;
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .breakeven-indicator {
            position: absolute;
            top: -5px;
            width: 3px;
            height: 28px;
            background: #ef4444;
            border-radius: 2px;
            z-index: 1;
            transition: left 0.3s ease;
        }

        .breakeven-indicator::before {
            content: 'Break-Even';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #ef4444;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .breakeven-indicator::after {
            content: '';
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid #ef4444;
        }

        .usage-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .usage-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
        }

        .usage-item label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #0d9488;
            margin-bottom: 6px;
            text-transform: uppercase;
        }

        .usage-item input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #d0d0d0;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.7px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #0d9488 0%, #065f46 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(13, 148, 136, 0.4);
        }

        .btn-secondary {
            background: #64748b;
            color: white;
        }

        .btn-secondary:hover {
            background: #475569;
        }

        .btn-export {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .btn-export:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .button-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .hedge-strategy-config {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #0d9488;
        }

        .hedge-mode-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
        }

        .hedge-mode-btn {
            flex: 1;
            padding: 15px 25px;
            border: 3px solid #e0e0e0;
            background: white;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .hedge-mode-btn.active {
            border-color: #0d9488;
            background: linear-gradient(135deg, #0d9488 0%, #065f46 100%);
            color: white;
        }

        .hedge-mode-btn:hover:not(.active) {
            border-color: #0d9488;
            background: #f0fdf4;
        }

        .hedge-matrix-table {
            overflow-x: auto;
            margin: 20px 0;
        }

        .hedge-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .hedge-table th {
            background: linear-gradient(135deg, #0d9488 0%, #065f46 100%);
            color: white;
            padding: 15px 12px;
            text-align: left;
            font-weight: 700;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border: 1px solid #0a7068;
        }

        .hedge-table td {
            padding: 12px;
            border: 1px solid #e5e7eb;
        }

        .hedge-table tr:hover {
            background: #f8fffe;
        }

        .hedge-table input[type="number"] {
            width: 90px;
            padding: 8px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            transition: border-color 0.2s;
        }

        .hedge-table input[type="number"]:focus {
            outline: none;
            border-color: #0d9488;
        }

        .month-cell {
            font-weight: 600;
            color: #0d9488;
            background: #f0fdf4;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .summary-card {
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
            padding: 25px;
            border-radius: 12px;
            border-left: 5px solid #0284c7;
        }

        .summary-card.success {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border-left-color: #10b981;
        }

        .summary-card.warning {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-left-color: #f59e0b;
        }

        .summary-card.danger {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border-left-color: #ef4444;
        }

        .summary-label {
            font-size: 12px;
            color: #4b5563;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        .summary-value {
            font-size: 28px;
            font-weight: 700;
            color: #1f2937;
            word-break: break-word;
            line-height: 1.2;
        }
        
        .summary-value.small-text {
            font-size: 22px;
        }

        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 16px;
            margin-bottom: 25px;
            position: relative;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.9),
                inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        }

        .chart-container::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            right: -6px;
            bottom: -6px;
            background: linear-gradient(135deg, #0d9488 0%, #065f46 50%, #0d9488 100%);
            border-radius: 18px;
            z-index: -1;
            box-shadow: 
                0 0 0 2px rgba(255, 255, 255, 0.1),
                0 4px 12px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .chart-header h3 {
            color: #1f2937;
            font-size: 20px;
        }

        .chart-controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .chart-toggle {
            display: flex;
            gap: 8px;
            background: #f3f4f6;
            padding: 4px;
            border-radius: 8px;
        }

        .chart-toggle-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.2s;
        }

        .chart-toggle-btn.active {
            background: white;
            color: #0d9488;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .view-toggle {
            display: flex;
            gap: 8px;
            background: #e0f2fe;
            padding: 4px;
            border-radius: 8px;
            border: 2px solid #0284c7;
        }

        .view-toggle-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 700;
            font-size: 13px;
            transition: all 0.2s;
            color: #0c4a6e;
        }

        .view-toggle-btn.active {
            background: #0284c7;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
            margin-top: 20px;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 13px;
        }

        .results-table th {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
            color: white;
            padding: 12px 10px;
            text-align: left;
            font-weight: 700;
            font-size: 12px;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .results-table td {
            padding: 10px;
            border-bottom: 1px solid #e5e7eb;
        }

        .results-table tbody tr {
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .results-table tbody tr:hover {
            background: #f0f9ff !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: scale(1.01);
        }

        .results-table tbody tr:nth-child(even) {
            background: #f8f9fa;
        }

        .positive-value {
            color: #10b981;
            font-weight: 700;
        }

        .negative-value {
            color: #ef4444;
            font-weight: 700;
        }

        .info-box {
            background: #dbeafe;
            border: 2px solid #3b82f6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .info-box h3 {
            color: #1e40af;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .info-box p {
            color: #1e3a8a;
            line-height: 1.6;
            font-size: 14px;
            margin: 5px 0;
        }

        .tabs-container {
            margin: 25px 0;
        }

        .tabs-nav {
            display: flex;
            gap: 4px;
            border-bottom: 3px solid #e5e7eb;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            border: none;
            background: transparent;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            color: #6b7280;
            transition: all 0.2s;
            margin-bottom: -3px;
        }

        .tab-btn.active {
            color: #0d9488;
            border-bottom-color: #0d9488;
        }

        .tab-btn:hover:not(.active) {
            color: #0d9488;
            background: #f0fdf4;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Bill Breakdown Tooltip */
        .bill-tooltip {
            position: fixed;
            background: white;
            border: 3px solid #0d9488;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 400px;
            max-width: 500px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .bill-tooltip.show {
            opacity: 1;
        }

        .bill-header {
            background: linear-gradient(135deg, #0d9488 0%, #065f46 100%);
            color: white;
            padding: 15px;
            margin: -20px -20px 15px -20px;
            border-radius: 9px 9px 0 0;
        }

        .bill-header h3 {
            font-size: 18px;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .bill-header p {
            font-size: 13px;
            opacity: 0.95;
        }

        .bill-section {
            margin-bottom: 15px;
        }

        .bill-section-title {
            font-size: 12px;
            font-weight: 700;
            color: #0d9488;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 2px solid #e5e7eb;
        }

        .bill-line {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 13px;
        }

        .bill-line-label {
            color: #4b5563;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bill-line-value {
            font-weight: 600;
            color: #1f2937;
        }

        .bill-line-rate {
            font-size: 11px;
            color: #6b7280;
            margin-left: 5px;
        }

        .bill-subtotal {
            border-top: 2px solid #e5e7eb;
            padding-top: 8px;
            margin-top: 8px;
            font-weight: 700;
        }

        .bill-total {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border: 2px solid #10b981;
            padding: 12px;
            margin-top: 15px;
            border-radius: 8px;
            font-weight: 700;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bill-total-label {
            color: #065f46;
        }

        .bill-total-value {
            color: #065f46;
            font-size: 20px;
        }

        .bill-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .indicator-capacity {
            background: #0d9488;
        }

        .indicator-transmission {
            background: #065f46;
        }

        .indicator-ancillary {
            background: #10b981;
        }

        .indicator-open {
            background: #f59e0b;
        }

        .indicator-hedged {
            background: #3b82f6;
        }

        @media (max-width: 768px) {
            .input-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 28px;
            }
            
            .hedge-mode-selector {
                flex-direction: column;
            }

            .chart-header {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }

            .term-info-content {
                flex-direction: column;
            }

            .chart-controls {
                width: 100%;
            }

            .bill-tooltip {
                min-width: 300px;
                max-width: 90vw;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <img src="https://www.sesenergy.org/assets/images/logo-2.jpg" alt="Secure Energy Logo" class="header-logo">
            <h1>Index Energy Cost Modeling and Comparison Tool</h1>
        </div>

        <!-- INPUT CONFIGURATION -->
        <div class="card">
            <div class="section-title">üìã Basic Parameters</div>
            
            <!-- Client Name Input - for tracking -->
            <div class="input-grid" style="margin-bottom: 20px;">
                <div class="input-group" style="grid-column: span 2;">
                    <label>üë§ Client / Project Name</label>
                    <input type="text" class="input-field" id="clientName" placeholder="Enter client or project name for tracking..." style="font-size: 16px;">
                </div>
            </div>
            
            <div class="input-grid">
                <div class="input-group">
                    <label>ISO / RTO</label>
                    <select class="input-field" id="iso" onchange="updateZoneOptions(); setDefaultDates()">
                        <option value="ISONE">ISO-NE</option>
                        <option value="PJM">PJM</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label>Zone</label>
                    <select class="input-field" id="zone" onchange="setDefaultDates()">
                        <!-- Populated dynamically -->
                    </select>
                </div>
                
                <div class="input-group">
                    <label>Contract Start Date</label>
                    <input type="month" class="input-field" id="startDate" value="2016-01" onchange="updateTermInfo()">
                </div>
                
                <div class="input-group">
                    <label>Contract Term (Months)</label>
                    <input type="number" class="input-field" id="termMonths" value="60" min="12" max="120" step="12" onchange="updateTermInfo()">
                </div>
                
                <div class="input-group">
                    <label>LMP Projection Method</label>
                    <select class="input-field" id="projectionMethod">
                        <option value="1">1-Year Rolling Average</option>
                        <option value="2">2-Year Rolling Average</option>
                        <option value="3">3-Year Rolling Average</option>
                        <option value="5" selected>5-Year Rolling Average</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label>LMP YoY Escalator (%)</label>
                    <input type="number" class="input-field" id="lmpEscalator" value="0" step="0.5" min="-20" max="20" placeholder="e.g., 2.5">
                </div>
            </div>
            
            <div class="info-box" style="margin-top: 15px;">
                <h3>üìÖ Default Settings</h3>
                <p><strong>Contract Start Date:</strong> Automatically set to 10 years before the last available actual LMP data for your selected ISO/Zone.</p>
                <p><strong>Contract Term:</strong> Defaults to 60 months (5 years).</p>
                <p><strong>LMP Projection:</strong> For future months beyond available data, the tool uses a rolling average of historical LMP values from the last 1-5 available years for the same calendar month.</p>
                <p><strong>LMP YoY Escalator:</strong> Applies a compounding annual adjustment to projected LMP values. For example, a 3% escalator increases projected LMP by 3% each year beyond the base projection year.</p>
            </div>

            <!-- TERM INFO BOX -->
            <div class="term-info-box" id="termInfoBox">
                <h3>üìÖ Contract Term Information</h3>
                <div class="term-info-content">
                    <div class="term-info-item">
                        <div class="term-info-label">Term Length</div>
                        <div class="term-info-value" id="termLength">36 Months</div>
                    </div>
                    <div class="term-info-item">
                        <div class="term-info-label">Start Date</div>
                        <div class="term-info-value" id="termStart">January 2025</div>
                    </div>
                    <div class="term-info-item">
                        <div class="term-info-label">End Date</div>
                        <div class="term-info-value" id="termEnd">December 2027</div>
                    </div>
                </div>
            </div>

            <div class="input-grid">
                <div class="input-group">
                    <label>Fixed All-In Price ($/kWh)</label>
                    <input type="number" class="input-field" id="fixedPrice" value="0.085" step="0.001" onchange="updateBreakEvenIndicator()">
                </div>
                
                <div class="input-group">
                    <label>Capacity ($/kWh)</label>
                    <input type="number" class="input-field" id="capacityCost" value="0.015" step="0.001">
                </div>
                
                <div class="input-group">
                    <label>Ancillary Services ($/kWh)</label>
                    <input type="number" class="input-field" id="ancillaryCost" value="0.005" step="0.001">
                </div>
                
                <div class="input-group">
                    <label>Transmission ($/kWh)</label>
                    <input type="number" class="input-field" id="transmissionCost" value="0.015" step="0.001">
                </div>
            </div>

            <div class="info-box">
                <h3>üí° Cost Calculation Formula (Simplified)</h3>
                <p><strong>Fixed Cost:</strong> Fixed All-In Price √ó Usage</p>
                <p><strong>Index Cost:</strong> [(Non-Energy Costs) + (LMP + 5%) √ó Open % + (Block Rate + 5%) √ó Hedged %] √ó Usage</p>
                <p style="margin-top: 10px; font-style: italic;">Where Non-Energy Costs = Capacity + Transmission + Ancillary Services</p>
                <p style="margin-top: 10px;"><strong>LMP Projection:</strong> For months beyond available data, uses the last 1-5 years of available data (as selected) for the same calendar month. The YoY Escalator applies compound annual growth to projected values. Example: Forecasting March 2028 with 3-year rolling when data ends in 2025 uses March 2023, 2024, and 2025, then applies the escalator for 3 years.</p>
            </div>
        </div>

        <!-- USAGE INPUT -->
        <div class="card">
            <div class="section-title">üìä Monthly Usage Profile (kWh)</div>
            <p style="color: #6b7280; margin-bottom: 15px; font-size: 14px;">
                Enter your facility's typical monthly usage. This pattern will repeat for each year of the contract.
            </p>
            
            <div class="usage-grid" id="usageGrid">
                <!-- Populated dynamically -->
            </div>
        </div>

        <!-- HEDGE STRATEGY -->
        <div class="card">
            <div class="section-title">üõ°Ô∏è Hedge Strategy Configuration</div>
            
            <div class="hedge-strategy-config">
                <div class="hedge-mode-selector">
                    <button class="hedge-mode-btn active" onclick="setHedgeMode('simple')" id="simpleModeBtn">
                        Simple: Fixed Percentage
                    </button>
                    <button class="hedge-mode-btn" onclick="setHedgeMode('matrix')" id="matrixModeBtn">
                        Advanced: Monthly Matrix
                    </button>
                </div>

                <!-- SIMPLE MODE -->
                <div id="simpleHedgeConfig" style="display: block;">
                    <div class="section-subtitle">Quick Apply Settings</div>
                    <div class="input-grid" style="max-width: 800px;">
                        <div class="input-group">
                            <label>Fixed Block Rate ($/kWh)</label>
                            <input type="number" class="input-field" id="simpleBlockRate" value="0.075" step="0.001">
                        </div>
                    </div>
                    
                    <!-- HEDGE PERCENTAGE SLIDER -->
                    <div class="slider-container" style="margin-top: 20px;">
                        <div class="slider-label">
                            <span>Hedge Percentage</span>
                            <span class="slider-value" id="simpleHedgeValue">50%</span>
                        </div>
                        <input type="range" min="0" max="100" value="50" class="slider" id="simpleHedgeSlider" 
                               oninput="updateSimpleHedgeValue()">
                    </div>

                    <button class="btn btn-secondary" onclick="applySimpleHedge()" style="margin-top: 15px;">
                        Apply to All Periods
                    </button>

                    <div class="info-box" style="margin-top: 20px;">
                        <h3>How It Works</h3>
                        <p>
                            Simple hedging applies the same fixed block rate and percentage across your entire contract. 
                            The calculation includes 5% line loss added to both the LMP and fixed block rate.
                            Your blended energy cost = ((LMP + 5%) √ó Open %) + ((Block Rate + 5%) √ó Hedged %)
                        </p>
                    </div>
                </div>

                <!-- MATRIX MODE -->
                <div id="matrixHedgeConfig" style="display: none;">
                    <div class="button-group">
                        <button class="btn btn-secondary" onclick="clearAllHedges()">Clear All Hedges</button>
                        <button class="btn btn-secondary" onclick="copyToAll()">Copy Year 1 to All Years</button>
                    </div>
                    <div class="hedge-matrix-table" id="hedgeMatrix">
                        <!-- Populated dynamically -->
                    </div>
                    <div class="info-box" style="margin-top: 20px;">
                        <h3>Advanced Matrix Configuration</h3>
                        <p>
                            Create custom hedging strategies by setting different fixed block rates and percentages for each month.
                            This allows you to hedge more during high-price seasons and less during low-price periods.
                            All rates automatically include 5% line loss in the calculation.
                        </p>
                    </div>
                </div>
            </div>

            <div class="button-group">
                <button class="btn btn-primary" onclick="calculate()">
                    ‚úì Calculate Results
                </button>
                <button class="btn btn-secondary" onclick="resetForm()" title="Clear results and reset form">
                    üîÑ Reset Form
                </button>
            </div>
        </div>

        <!-- LMP ADJUSTMENT SLIDER (above results) -->
        <div class="card" id="lmpSliderCard" style="display: none;">
            <div class="section-title">üéöÔ∏è Dynamic LMP Adjustment</div>
            
            <div class="slider-container">
                <div class="slider-label">
                    <span>LMP Adjustment Factor</span>
                    <span class="slider-value" id="lmpAdjustValue">+0.0%</span>
                </div>
                <div class="slider-wrapper">
                    <div class="breakeven-indicator" id="breakevenIndicator"></div>
                    <input type="range" min="-100" max="100" value="0" step="0.5" class="slider" id="lmpAdjustSlider" 
                           oninput="updateLmpAdjustValue(); recalculateLive()">
                </div>
                <p style="font-size: 12px; color: #6b7280; margin-top: 8px;">
                    <strong>Real-time adjustment:</strong> Move the slider to instantly see how LMP changes affect your analysis (-100% to +100% in 0.5% increments). 
                    The red line shows the break-even point where fixed becomes cheaper than index.
                </p>
            </div>
        </div>

        <!-- RESULTS -->
        <div class="card" id="resultsCard" style="display: none;">
            <div class="section-title">üìà Analysis Results</div>
            
            <!-- PROJECTION NOTICE (if applicable) -->
            <div class="projection-notice" id="projectionNotice" style="display: none;">
                <h3>‚ö†Ô∏è Projected LMP Data Notice</h3>
                <p id="projectionMessage"></p>
            </div>

            <div class="summary-grid" id="summaryCards">
                <!-- Populated dynamically -->
            </div>

            <!-- TABS FOR DIFFERENT VIEWS -->
            <div class="tabs-container">
                <div class="tabs-nav">
                    <button class="tab-btn active" onclick="switchTab('overview')">Overview Charts</button>
                    <button class="tab-btn" onclick="switchTab('breakdown')">Cost Breakdown</button>
                    <button class="tab-btn" onclick="switchTab('yearly')">Year Over Year</button>
                    <button class="tab-btn" onclick="switchTab('monthly')">Monthly Detail</button>
                </div>

                <!-- OVERVIEW TAB -->
                <div class="tab-content active" id="overviewTab">
                    <div class="chart-container">
                        <div class="chart-header">
                            <h3>Cumulative Comparison</h3>
                            <div class="chart-controls">
                                <div class="view-toggle">
                                    <button class="view-toggle-btn active" onclick="toggleCumulativeView('cost')">Cost ($)</button>
                                    <button class="view-toggle-btn" onclick="toggleCumulativeView('rate')">Rate ($/kWh)</button>
                                </div>
                                <div class="chart-toggle">
                                    <button class="chart-toggle-btn active" onclick="toggleCumulativeChart('line')">Line</button>
                                    <button class="chart-toggle-btn" onclick="toggleCumulativeChart('bar')">Bar</button>
                                </div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="cumulativeChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <h3>Monthly Comparison</h3>
                            <div class="chart-controls">
                                <div class="view-toggle">
                                    <button class="view-toggle-btn active" onclick="toggleMonthlyView('cost')">Cost ($)</button>
                                    <button class="view-toggle-btn" onclick="toggleMonthlyView('rate')">Rate ($/kWh)</button>
                                </div>
                                <div class="chart-toggle">
                                    <button class="chart-toggle-btn" onclick="toggleMonthlyChart('line')">Line</button>
                                    <button class="chart-toggle-btn active" onclick="toggleMonthlyChart('bar')">Bar</button>
                                </div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="monthlyChart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- BREAKDOWN TAB -->
                <div class="tab-content" id="breakdownTab">
                    <div class="chart-container">
                        <h3 style="margin-bottom: 20px;">Cost Component Breakdown</h3>
                        <div class="chart-wrapper">
                            <canvas id="pieChart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- YEARLY TAB -->
                <div class="tab-content" id="yearlyTab">
                    <div class="chart-container">
                        <div class="chart-header">
                            <h3>Year Over Year Comparison</h3>
                            <div class="view-toggle">
                                <button class="view-toggle-btn active" onclick="toggleYearlyView('cost')">Cost ($)</button>
                                <button class="view-toggle-btn" onclick="toggleYearlyView('rate')">Rate ($/kWh)</button>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="yearlyChart"></canvas>
                        </div>
                        <div style="overflow-x: auto; margin-top: 25px;">
                            <table class="results-table" id="yearlyTable">
                                <!-- Populated dynamically -->
                            </table>
                        </div>
                    </div>
                </div>

                <!-- MONTHLY TAB -->
                <div class="tab-content" id="monthlyDetailTab">
                    <div class="chart-container">
                        <div class="chart-header">
                            <h3>Month-by-Month Analysis</h3>
                            <div class="view-toggle">
                                <button class="view-toggle-btn active" onclick="toggleMonthByMonthView('cost')">Cost ($)</button>
                                <button class="view-toggle-btn" onclick="toggleMonthByMonthView('rate')">Rate ($/kWh)</button>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="monthByMonthChart"></canvas>
                        </div>
                        
                        <div class="info-box" style="margin-top: 25px;">
                            <h3>üí° Interactive Table</h3>
                            <p>Hover over any row in the table below to see a detailed breakdown like an energy supply bill, showing costs and rates for each component.</p>
                        </div>

                        <div style="overflow-x: auto; max-height: 600px;">
                            <table class="results-table" id="detailedTable">
                                <!-- Populated dynamically -->
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="button-group">
                <button class="btn btn-export" onclick="exportToExcel()">
                    üìä Export to Excel
                </button>
                <button class="btn btn-export" onclick="exportToPowerPoint()">
                    üìΩÔ∏è Export to PowerPoint
                </button>
            </div>
        </div>
    </div>

    <!-- BILL BREAKDOWN TOOLTIP -->
    <div class="bill-tooltip" id="billTooltip"></div>

    <script>
        // EMBEDDED REAL LMP DATA
        // ========================================
        // LMP Data Configuration
        // ========================================
        // Data is now loaded externally instead of being embedded
        // Configure the data source URL in LMP_DATA_CONFIG below
        
        const LMP_DATA_CONFIG = {
            // Set this to the URL of your JSON data file
            // Example: 'https://raw.githubusercontent.com/your-repo/data/lmp-data.json'
            DATA_URL: '',
            
            // Fallback to localStorage if external load fails
            USE_LOCALSTORAGE_FALLBACK: true
        };
        
        // Initialize empty ISO_DATA - will be populated from external source
        let ISO_DATA = {};
        // CONSTANTS
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const monthsFull = ['January', 'February', 'March', 'April', 'May', 'June', 
                            'July', 'August', 'September', 'October', 'November', 'December'];
        const LINE_LOSS = 0.05;

        // STATE
        let currentHedgeMode = 'simple';
        let hedgeMatrix = {};
        let calculationResults = null;
        let baseLMPData = null; // Store original LMP data
        let projectedMonths = [];
        let cumulativeChart = null;
        let monthlyChart = null;
        let pieChart = null;
        let yearlyChart = null;
        let monthByMonthChart = null;
        let cumulativeChartType = 'line';
        let monthlyChartType = 'bar';
        let cumulativeViewMode = 'cost';
        let monthlyViewMode = 'cost';
        let yearlyViewMode = 'cost';
        let monthByMonthViewMode = 'cost';

        let zoneData = {
            'ISONE': [
                { value: '4000_ISONE', label: 'ISO NE CA' },
                { value: '4001_Maine', label: 'ME' },
                { value: '4002_NH', label: 'NH' },
                { value: '4003_Vermont', label: 'VT' },
                { value: '4004_Connecticut', label: 'CT' },
                { value: '4005_Rhode_Island', label: 'RI' },
                { value: '4006_SEMA', label: 'SEMA' },
                { value: '4007_WCMA', label: 'WCMA' },
                { value: '4008_NEMA', label: 'NEMA' }
            ],
            'PJM': [
                { value: 'AECO', label: 'AECO' },
                { value: 'AEP', label: 'AEP' },
                { value: 'APS', label: 'APS' },
                { value: 'ATSI', label: 'ATSI' },
                { value: 'BGE', label: 'BGE' },
                { value: 'COMED', label: 'COMED' },
                { value: 'DOM', label: 'DOM' },
                { value: 'DPL', label: 'DPL' },
                { value: 'EXTERNAL', label: 'EXTERNAL' },
                { value: 'JCPL', label: 'JCPL' },
                { value: 'METED', label: 'METED' },
                { value: 'PECO', label: 'PECO' },
                { value: 'PENELEC', label: 'PENELEC' },
                { value: 'PEPCO', label: 'PEPCO' },
                { value: 'PPL', label: 'PPL' },
                { value: 'PSEG', label: 'PSEG' }
            ],
            'NYISO': [],
            'MISO': [],
            'ERCOT': [],
            'CAISO': [],
            'SPP': []
        };

        const defaultUsage = {
            0: 185000, 1: 168000, 2: 142000, 3: 118000,
            4: 105000, 5: 135000, 6: 198000, 7: 205000,
            8: 152000, 9: 125000, 10: 138000, 11: 172000
        };

        // INITIALIZE
        document.addEventListener('DOMContentLoaded', function() {
            updateZoneOptions();
            initializeUsageGrid();
            initializeHedgeMatrix();
            setDefaultDates();
            updateTermInfo();
            updateBreakEvenIndicator();
        });

        function setDefaultDates() {
            const iso = document.getElementById('iso').value;
            const zone = document.getElementById('zone').value;
            
            // Find the last available actual LMP data for this ISO/Zone
            const dataSet = ISO_DATA[iso];
            if (!dataSet) return;
            
            // Filter for selected zone and find latest date
            const zoneData = dataSet.filter(r => r.zone === zone);
            if (zoneData.length === 0) return;
            
            // Find max year and month
            let maxYear = 0;
            let maxMonth = 0;
            
            zoneData.forEach(r => {
                const year = parseInt(r.year);
                const month = parseInt(r.month);
                
                if (year > maxYear || (year === maxYear && month > maxMonth)) {
                    maxYear = year;
                    maxMonth = month;
                }
            });
            
            if (maxYear === 0) return;
            
            // Set end date to last available data
            const endDate = new Date(maxYear, maxMonth - 1, 1);
            
            // Set start date to 10 years (120 months) before end date
            const startDate = new Date(endDate);
            startDate.setMonth(startDate.getMonth() - 119); // 119 months back + current month = 120 total
            
            // Format as YYYY-MM
            const startYear = startDate.getFullYear();
            const startMonth = String(startDate.getMonth() + 1).padStart(2, '0');
            
            // Update fields
            document.getElementById('startDate').value = `${startYear}-${startMonth}`;
            document.getElementById('termMonths').value = '120';
            
            updateTermInfo();
        }

        function updateZoneOptions() {
            const iso = document.getElementById('iso').value;
            const zoneSelect = document.getElementById('zone');
            zoneSelect.innerHTML = '';
            
            // First try to get zones from ISO_DATA (loaded from JSON)
            if (ISO_DATA[iso] && ISO_DATA[iso].length > 0) {
                // Build unique zones from the data
                const uniqueZones = {};
                ISO_DATA[iso].forEach(record => {
                    const zoneValue = record.zone || record.zone_name || '';
                    const zoneLabel = record.zone_name || record.zone || '';
                    if (zoneValue && !uniqueZones[zoneValue]) {
                        uniqueZones[zoneValue] = zoneLabel;
                    }
                });
                
                // Sort and add to dropdown
                Object.keys(uniqueZones).sort().forEach(zoneValue => {
                    const option = document.createElement('option');
                    option.value = zoneValue;
                    option.textContent = uniqueZones[zoneValue] || zoneValue;
                    zoneSelect.appendChild(option);
                });
                
                // Also update zoneData for this ISO for future use
                if (!zoneData[iso] || zoneData[iso].length === 0) {
                    zoneData[iso] = Object.keys(uniqueZones).map(value => ({
                        value: value,
                        label: uniqueZones[value] || value
                    }));
                }
            } 
            // Fall back to hardcoded zoneData
            else if (zoneData[iso] && zoneData[iso].length > 0) {
                zoneData[iso].forEach(zone => {
                    const option = document.createElement('option');
                    option.value = zone.value;
                    option.textContent = zone.label;
                    zoneSelect.appendChild(option);
                });
            }
            // No zones available
            else {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '-- No zones available --';
                zoneSelect.appendChild(option);
            }
        }

        function initializeUsageGrid() {
            const grid = document.getElementById('usageGrid');
            grid.innerHTML = '';
            
            monthsFull.forEach((month, idx) => {
                const div = document.createElement('div');
                div.className = 'usage-item';
                div.innerHTML = `
                    <label>${month}</label>
                    <input type="number" id="usage_${idx}" value="${defaultUsage[idx]}" 
                           step="1000" min="0" class="usage-input">
                `;
                grid.appendChild(div);
            });
        }

        function updateTermInfo() {
            const startDate = document.getElementById('startDate').value;
            const termMonths = parseInt(document.getElementById('termMonths').value);
            
            if (!startDate) return;
            
            const [startYear, startMonth] = startDate.split('-').map(Number);
            const startDateObj = new Date(startYear, startMonth - 1, 1);
            const endDateObj = new Date(startYear, startMonth - 1 + termMonths, 0);
            
            const startFormatted = monthsFull[startDateObj.getMonth()] + ' ' + startDateObj.getFullYear();
            const endFormatted = monthsFull[endDateObj.getMonth()] + ' ' + endDateObj.getFullYear();
            
            document.getElementById('termLength').textContent = termMonths + ' Months';
            document.getElementById('termStart').textContent = startFormatted;
            document.getElementById('termEnd').textContent = endFormatted;
        }

        function updateLmpAdjustValue() {
            const slider = document.getElementById('lmpAdjustSlider');
            const value = parseFloat(slider.value);
            document.getElementById('lmpAdjustValue').textContent = 
                (value >= 0 ? '+' : '') + value.toFixed(1) + '%';
        }

        function updateSimpleHedgeValue() {
            const slider = document.getElementById('simpleHedgeSlider');
            document.getElementById('simpleHedgeValue').textContent = slider.value + '%';
        }

        function setHedgeMode(mode) {
            currentHedgeMode = mode;
            
            document.getElementById('simpleModeBtn').classList.toggle('active', mode === 'simple');
            document.getElementById('matrixModeBtn').classList.toggle('active', mode === 'matrix');
            
            document.getElementById('simpleHedgeConfig').style.display = mode === 'simple' ? 'block' : 'none';
            document.getElementById('matrixHedgeConfig').style.display = mode === 'matrix' ? 'block' : 'none';
        }

        function initializeHedgeMatrix() {
            const termMonths = parseInt(document.getElementById('termMonths').value);
            const years = Math.ceil(termMonths / 12);
            
            for (let year = 0; year < years; year++) {
                for (let month = 0; month < 12; month++) {
                    const key = `${year}_${month}`;
                    if (!hedgeMatrix[key]) {
                        hedgeMatrix[key] = { rate: 0.075, percent: 0 };
                    }
                }
            }
            
            renderHedgeMatrix();
        }

        function renderHedgeMatrix() {
            const termMonths = parseInt(document.getElementById('termMonths').value);
            const years = Math.ceil(termMonths / 12);
            const container = document.getElementById('hedgeMatrix');
            
            let html = '<table class="hedge-table"><thead><tr>';
            html += '<th>Month</th>';
            for (let year = 1; year <= years; year++) {
                html += `<th colspan="2" style="text-align: center;">Year ${year}</th>`;
            }
            html += '</tr><tr><th></th>';
            for (let year = 1; year <= years; year++) {
                html += '<th>Block Rate ($/kWh)</th><th>Hedged %</th>';
            }
            html += '</tr></thead><tbody>';
            
            for (let month = 0; month < 12; month++) {
                html += `<tr><td class="month-cell">${monthsFull[month]}</td>`;
                for (let year = 0; year < years; year++) {
                    const key = `${year}_${month}`;
                    const data = hedgeMatrix[key] || { rate: 0.075, percent: 0 };
                    html += `
                        <td>
                            <input type="number" step="0.001" value="${data.rate.toFixed(3)}" 
                                   onchange="updateHedgeMatrix(${year}, ${month}, 'rate', this.value)">
                        </td>
                        <td>
                            <input type="number" step="5" min="0" max="100" value="${data.percent}" 
                                   onchange="updateHedgeMatrix(${year}, ${month}, 'percent', this.value)">
                        </td>
                    `;
                }
                html += '</tr>';
            }
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function updateHedgeMatrix(year, month, field, value) {
            const key = `${year}_${month}`;
            if (!hedgeMatrix[key]) hedgeMatrix[key] = { rate: 0.075, percent: 0 };
            hedgeMatrix[key][field] = parseFloat(value);
        }

        function applySimpleHedge() {
            const rate = parseFloat(document.getElementById('simpleBlockRate').value);
            const percent = parseFloat(document.getElementById('simpleHedgeSlider').value);
            
            const termMonths = parseInt(document.getElementById('termMonths').value);
            const years = Math.ceil(termMonths / 12);
            
            for (let year = 0; year < years; year++) {
                for (let month = 0; month < 12; month++) {
                    const key = `${year}_${month}`;
                    hedgeMatrix[key] = { rate, percent };
                }
            }
            
            if (currentHedgeMode === 'matrix') {
                renderHedgeMatrix();
            }
            
            if (calculationResults) {
                calculate();
            }
            
            alert(`Applied ${percent}% hedge at $${rate.toFixed(3)}/kWh to all periods`);
        }

        function clearAllHedges() {
            if (!confirm('Clear all hedge settings?')) return;
            
            const termMonths = parseInt(document.getElementById('termMonths').value);
            const years = Math.ceil(termMonths / 12);
            
            for (let year = 0; year < years; year++) {
                for (let month = 0; month < 12; month++) {
                    const key = `${year}_${month}`;
                    hedgeMatrix[key] = { rate: 0.075, percent: 0 };
                }
            }
            
            renderHedgeMatrix();
            
            if (calculationResults) {
                calculate();
            }
        }

        function copyToAll() {
            const termMonths = parseInt(document.getElementById('termMonths').value);
            const years = Math.ceil(termMonths / 12);
            
            for (let year = 1; year < years; year++) {
                for (let month = 0; month < 12; month++) {
                    const sourceKey = `0_${month}`;
                    const targetKey = `${year}_${month}`;
                    hedgeMatrix[targetKey] = { ...hedgeMatrix[sourceKey] };
                }
            }
            
            renderHedgeMatrix();
            
            if (calculationResults) {
                calculate();
            }
            
            alert('Copied Year 1 settings to all years');
        }

        function getLMPData(iso, zone, targetYear, targetMonth, useAdjustment = true) {
            const dataSet = ISO_DATA[iso];
            if (!dataSet) return { lmp: null, isProjected: false };
            
            // Always use padded string format for month (data is stored as "01", "02", etc.)
            const monthKey = String(targetMonth + 1).padStart(2, '0');
            
            const record = dataSet.find(r => {
                const recordMonth = r.month;
                const recordYear = r.year;
                const recordZone = r.zone;
                
                return recordZone === zone && 
                       parseInt(recordYear) === targetYear && 
                       recordMonth === monthKey;
            });
            
            if (record && record.avg_da_lmp) {
                let lmp = record.avg_da_lmp / 1000;
                
                if (useAdjustment) {
                    const adjustPercent = parseFloat(document.getElementById('lmpAdjustSlider').value);
                    lmp = lmp * (1 + adjustPercent / 100);
                }
                
                return { lmp, isProjected: false };
            }
            
            // Get projection method (1-5 year rolling average)
            const projectionYears = parseInt(document.getElementById('projectionMethod').value);
            
            // Collect ALL available years for this zone/month, then use the last N available
            const availableYearsData = [];
            dataSet.forEach(r => {
                const recordMonth = r.month;
                const recordZone = r.zone;
                const recordYear = parseInt(r.year);
                
                // Match zone and month, collect all available years (we'll sort and pick most recent)
                if (recordZone === zone && 
                    recordMonth === monthKey &&
                    r.avg_da_lmp) {
                    availableYearsData.push({
                        year: recordYear,
                        lmp: r.avg_da_lmp
                    });
                }
            });
            
            // Sort by year descending to get most recent years first
            availableYearsData.sort((a, b) => b.year - a.year);
            
            // Take the last N available years (up to projectionYears) from available data
            const historicalValues = availableYearsData
                .slice(0, projectionYears)
                .map(d => d.lmp);
            
            if (historicalValues.length > 0) {
                const avgLmp = historicalValues.reduce((a, b) => a + b, 0) / historicalValues.length;
                let lmp = avgLmp / 1000;
                
                // Apply YoY escalator for projected values
                const escalatorPercent = parseFloat(document.getElementById('lmpEscalator').value) || 0;
                if (escalatorPercent !== 0 && availableYearsData.length > 0) {
                    // Calculate years ahead from the most recent actual data year
                    const lastDataYear = availableYearsData[0].year;
                    const yearsAhead = targetYear - lastDataYear;
                    if (yearsAhead > 0) {
                        // Apply compound escalator
                        lmp = lmp * Math.pow(1 + escalatorPercent / 100, yearsAhead);
                    }
                }
                
                if (useAdjustment) {
                    const adjustPercent = parseFloat(document.getElementById('lmpAdjustSlider').value);
                    lmp = lmp * (1 + adjustPercent / 100);
                }
                
                return { lmp, isProjected: true, yearsAveraged: historicalValues.length };
            }
            
            return { lmp: null, isProjected: false };
        }

        // Calculate break-even point and update indicator
        function updateBreakEvenIndicator() {
            if (!baseLMPData || baseLMPData.length === 0) return;
            
            const fixedPrice = parseFloat(document.getElementById('fixedPrice').value);
            const capacityCost = parseFloat(document.getElementById('capacityCost').value);
            const ancillaryCost = parseFloat(document.getElementById('ancillaryCost').value);
            const transmissionCost = parseFloat(document.getElementById('transmissionCost').value);
            
            const nonEnergyCostPerKwh = capacityCost + ancillaryCost + transmissionCost;
            
            // Get average base LMP
            const avgBaseLMP = baseLMPData.reduce((sum, val) => sum + val, 0) / baseLMPData.length;
            
            // Calculate what LMP adjustment would make index = fixed
            // fixedPrice = nonEnergyCostPerKwh + (avgBaseLMP * (1 + adj/100) * 1.05)
            // Solve for adj:
            const targetEnergyRate = fixedPrice - nonEnergyCostPerKwh;
            const baseEnergyRate = avgBaseLMP * (1 + LINE_LOSS);
            
            let breakevenPercent = ((targetEnergyRate / baseEnergyRate) - 1) * 100;
            
            // Clamp to slider range (-100 to +100)
            breakevenPercent = Math.max(-100, Math.min(100, breakevenPercent));
            
            // Position indicator (slider is -100 to +100, so 0-100 range, 50 = center)
            const sliderPosition = ((breakevenPercent + 100) / 200) * 100;
            
            const indicator = document.getElementById('breakevenIndicator');
            indicator.style.left = sliderPosition + '%';
        }

        // Live recalculation when slider moves
        function recalculateLive() {
            if (calculationResults && calculationResults.length > 0) {
                // Recalculate without scrolling
                const iso = document.getElementById('iso').value;
                const zone = document.getElementById('zone').value;
                const startDate = document.getElementById('startDate').value;
                const [startYear, startMonth] = startDate.split('-').map(Number);
                const termMonths = parseInt(document.getElementById('termMonths').value);
                const fixedPrice = parseFloat(document.getElementById('fixedPrice').value);
                const capacityCost = parseFloat(document.getElementById('capacityCost').value);
                const ancillaryCost = parseFloat(document.getElementById('ancillaryCost').value);
                const transmissionCost = parseFloat(document.getElementById('transmissionCost').value);
                
                const usage = [];
                for (let i = 0; i < 12; i++) {
                    usage.push(parseFloat(document.getElementById(`usage_${i}`).value) || 0);
                }
                
                calculationResults = [];
                projectedMonths = [];
                let cumIndex = 0, cumFixed = 0, cumUsage = 0;
                
                for (let i = 0; i < termMonths; i++) {
                    const contractYear = Math.floor(i / 12);
                    const monthInYear = i % 12;
                    const actualMonth = (startMonth - 1 + i) % 12;
                    const actualYear = startYear + Math.floor((startMonth - 1 + i) / 12);
                    
                    const usageKwh = usage[actualMonth];
                    const lmpResult = getLMPData(iso, zone, actualYear, actualMonth);
                    const lmp = lmpResult.lmp;
                    
                    if (lmp === null) continue;
                    
                    if (lmpResult.isProjected) {
                        projectedMonths.push({
                            month: monthsFull[actualMonth],
                            year: actualYear,
                            yearsAveraged: lmpResult.yearsAveraged
                        });
                    }
                    
                    const fixedTotalCost = fixedPrice * usageKwh;
                    const nonEnergyCostPerKwh = capacityCost + ancillaryCost + transmissionCost;
                    
                    const hedgeKey = `${contractYear}_${monthInYear}`;
                    const hedgeData = hedgeMatrix[hedgeKey] || { rate: 0, percent: 0 };
                    const openPercent = (100 - hedgeData.percent) / 100;
                    const hedgedPercent = hedgeData.percent / 100;
                    
                    const lmpWithLineLoss = lmp * (1 + LINE_LOSS);
                    const blockRateWithLineLoss = hedgeData.rate * (1 + LINE_LOSS);
                    
                    const energyCostPerKwh = (lmpWithLineLoss * openPercent) + (blockRateWithLineLoss * hedgedPercent);
                    const blendedRatePerKwh = nonEnergyCostPerKwh + energyCostPerKwh;
                    const indexTotalCost = blendedRatePerKwh * usageKwh;
                    
                    const capacityCostMonth = capacityCost * usageKwh;
                    const ancillaryCostMonth = ancillaryCost * usageKwh;
                    const transmissionCostMonth = transmissionCost * usageKwh;
                    const openEnergyCost = lmpWithLineLoss * openPercent * usageKwh;
                    const hedgedEnergyCost = blockRateWithLineLoss * hedgedPercent * usageKwh;
                    
                    cumIndex += indexTotalCost;
                    cumFixed += fixedTotalCost;
                    cumUsage += usageKwh;
                    
                    calculationResults.push({
                        period: i + 1,
                        contractYear: contractYear + 1,
                        actualYear: actualYear,
                        month: monthsFull[monthInYear],
                        monthShort: months[monthInYear],
                        monthNum: monthInYear,
                        usageKwh,
                        lmp,
                        lmpWithLineLoss,
                        blockRate: hedgeData.rate,
                        blockRateWithLineLoss,
                        hedgePercent: hedgeData.percent,
                        openPercent: openPercent * 100,
                        blendedRate: blendedRatePerKwh,
                        capacityCost: capacityCostMonth,
                        capacityRate: capacityCost,
                        ancillaryCost: ancillaryCostMonth,
                        ancillaryRate: ancillaryCost,
                        transmissionCost: transmissionCostMonth,
                        transmissionRate: transmissionCost,
                        openEnergyCost,
                        openEnergyRate: lmpWithLineLoss * openPercent,
                        hedgedEnergyCost,
                        hedgedEnergyRate: blockRateWithLineLoss * hedgedPercent,
                        indexCost: indexTotalCost,
                        fixedCost: fixedTotalCost,
                        cumIndex,
                        cumFixed,
                        cumUsage,
                        isProjected: lmpResult.isProjected,
                        indexRate: indexTotalCost / usageKwh,
                        fixedRate: fixedPrice
                    });
                }
                
                // Update displays without scrolling
                updateResultsDisplay();
            }
        }

        function updateResultsDisplay() {
            // Update projection notice
            if (projectedMonths.length > 0) {
                const notice = document.getElementById('projectionNotice');
                notice.style.display = 'block';
                
                const monthList = projectedMonths.map(p => `${p.month} ${p.year}`).join(', ');
                const avgYears = Math.round(projectedMonths.reduce((sum, p) => sum + p.yearsAveraged, 0) / projectedMonths.length);
                const projectionMethod = document.getElementById('projectionMethod').value;
                const escalator = parseFloat(document.getElementById('lmpEscalator').value) || 0;
                
                let escalatorNote = '';
                if (escalator !== 0) {
                    escalatorNote = ` A <strong>${escalator > 0 ? '+' : ''}${escalator}% YoY escalator</strong> has been applied to projected values.`;
                }
                
                document.getElementById('projectionMessage').innerHTML = 
                    `<strong>Projected LMP values used for:</strong> ${monthList}. ` +
                    `These values are calculated using a <strong>${projectionMethod}-year rolling average</strong> of the same month over the preceding ${avgYears} year${avgYears > 1 ? 's' : ''} ` +
                    `and are marked with a <span class="projected-badge">PROJECTED</span> badge in the detailed table.${escalatorNote}`;
            } else {
                document.getElementById('projectionNotice').style.display = 'none';
            }
            
            // Update summary cards
            const lastResult = calculationResults[calculationResults.length - 1];
            const totalIndexCost = lastResult.cumIndex;
            const totalFixedCost = lastResult.cumFixed;
            const savingsVsFixed = totalFixedCost - totalIndexCost;
            
            const totalUsage = calculationResults.reduce((sum, r) => sum + r.usageKwh, 0);
            const avgBlendedRate = totalIndexCost / totalUsage;
            
            const summaryHTML = `
                <div class="summary-card">
                    <div class="summary-label">Total Index Cost</div>
                    <div class="summary-value">$${totalIndexCost.toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                </div>
                <div class="summary-card">
                    <div class="summary-label">Total Fixed Cost</div>
                    <div class="summary-value">$${totalFixedCost.toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                </div>
                <div class="summary-card ${savingsVsFixed > 0 ? 'success' : 'warning'}">
                    <div class="summary-label">Savings vs Fixed</div>
                    <div class="summary-value ${savingsVsFixed >= 0 ? 'positive-value' : 'negative-value'}">
                        ${savingsVsFixed >= 0 ? '+' : ''}$${savingsVsFixed.toLocaleString(undefined, {maximumFractionDigits: 0})}
                    </div>
                </div>
                <div class="summary-card">
                    <div class="summary-label">Avg Blended Rate</div>
                    <div class="summary-value small-text">$${avgBlendedRate.toFixed(5)}/kWh</div>
                </div>
            `;
            document.getElementById('summaryCards').innerHTML = summaryHTML;
            
            // Update all visualizations
            renderAllCharts();
            renderDetailedTable();
            renderYearlyTable();
        }

        function calculate() {
            const iso = document.getElementById('iso').value;
            const zone = document.getElementById('zone').value;
            const startDate = document.getElementById('startDate').value;
            const [startYear, startMonth] = startDate.split('-').map(Number);
            const termMonths = parseInt(document.getElementById('termMonths').value);
            const fixedPrice = parseFloat(document.getElementById('fixedPrice').value);
            const capacityCost = parseFloat(document.getElementById('capacityCost').value);
            const ancillaryCost = parseFloat(document.getElementById('ancillaryCost').value);
            const transmissionCost = parseFloat(document.getElementById('transmissionCost').value);
            
            const usage = [];
            for (let i = 0; i < 12; i++) {
                usage.push(parseFloat(document.getElementById(`usage_${i}`).value) || 0);
            }
            
            // Store base LMP data (without adjustment) for break-even calculation
            if (!baseLMPData || baseLMPData.length === 0) {
                baseLMPData = [];
                for (let i = 0; i < termMonths; i++) {
                    const actualMonth = (startMonth - 1 + i) % 12;
                    const actualYear = startYear + Math.floor((startMonth - 1 + i) / 12);
                    const lmpResult = getLMPData(iso, zone, actualYear, actualMonth, false);
                    if (lmpResult.lmp !== null) {
                        baseLMPData.push(lmpResult.lmp);
                    }
                }
                updateBreakEvenIndicator();
            }
            
            calculationResults = [];
            projectedMonths = [];
            let cumIndex = 0, cumFixed = 0, cumUsage = 0;
            let hasErrors = false;
            
            for (let i = 0; i < termMonths; i++) {
                const contractYear = Math.floor(i / 12);
                const monthInYear = i % 12;
                const actualMonth = (startMonth - 1 + i) % 12;
                const actualYear = startYear + Math.floor((startMonth - 1 + i) / 12);
                
                const usageKwh = usage[actualMonth];
                const lmpResult = getLMPData(iso, zone, actualYear, actualMonth);
                const lmp = lmpResult.lmp;
                
                if (lmp === null) {
                    console.warn(`No LMP data for ${iso} ${zone} ${actualYear}-${actualMonth + 1}`);
                    hasErrors = true;
                    continue;
                }
                
                if (lmpResult.isProjected) {
                    projectedMonths.push({
                        month: monthsFull[actualMonth],
                        year: actualYear,
                        yearsAveraged: lmpResult.yearsAveraged
                    });
                }
                
                const fixedTotalCost = fixedPrice * usageKwh;
                const nonEnergyCostPerKwh = capacityCost + ancillaryCost + transmissionCost;
                
                const hedgeKey = `${contractYear}_${monthInYear}`;
                const hedgeData = hedgeMatrix[hedgeKey] || { rate: 0, percent: 0 };
                const openPercent = (100 - hedgeData.percent) / 100;
                const hedgedPercent = hedgeData.percent / 100;
                
                const lmpWithLineLoss = lmp * (1 + LINE_LOSS);
                const blockRateWithLineLoss = hedgeData.rate * (1 + LINE_LOSS);
                
                const energyCostPerKwh = (lmpWithLineLoss * openPercent) + (blockRateWithLineLoss * hedgedPercent);
                const blendedRatePerKwh = nonEnergyCostPerKwh + energyCostPerKwh;
                const indexTotalCost = blendedRatePerKwh * usageKwh;
                
                const capacityCostMonth = capacityCost * usageKwh;
                const ancillaryCostMonth = ancillaryCost * usageKwh;
                const transmissionCostMonth = transmissionCost * usageKwh;
                const openEnergyCost = lmpWithLineLoss * openPercent * usageKwh;
                const hedgedEnergyCost = blockRateWithLineLoss * hedgedPercent * usageKwh;
                
                cumIndex += indexTotalCost;
                cumFixed += fixedTotalCost;
                cumUsage += usageKwh;
                
                calculationResults.push({
                    period: i + 1,
                    contractYear: contractYear + 1,
                    actualYear: actualYear,
                    month: monthsFull[monthInYear],
                    monthShort: months[monthInYear],
                    monthNum: monthInYear,
                    usageKwh,
                    lmp,
                    lmpWithLineLoss,
                    blockRate: hedgeData.rate,
                    blockRateWithLineLoss,
                    hedgePercent: hedgeData.percent,
                    openPercent: openPercent * 100,
                    blendedRate: blendedRatePerKwh,
                    capacityCost: capacityCostMonth,
                    capacityRate: capacityCost,
                    ancillaryCost: ancillaryCostMonth,
                    ancillaryRate: ancillaryCost,
                    transmissionCost: transmissionCostMonth,
                    transmissionRate: transmissionCost,
                    openEnergyCost,
                    openEnergyRate: lmpWithLineLoss * openPercent,
                    hedgedEnergyCost,
                    hedgedEnergyRate: blockRateWithLineLoss * hedgedPercent,
                    indexCost: indexTotalCost,
                    fixedCost: fixedTotalCost,
                    cumIndex,
                    cumFixed,
                    cumUsage,
                    isProjected: lmpResult.isProjected,
                    indexRate: indexTotalCost / usageKwh,
                    fixedRate: fixedPrice
                });
            }
            
            if (hasErrors) {
                alert('Warning: Some months have missing LMP data and could not be projected.');
            }
            
            if (calculationResults.length > 0) {
                displayResults();
                
                // Log analysis to activity tracker
                logAnalysisToParent();
            } else {
                alert('Unable to calculate results. Please check your date range and zone selection.');
            }
        }
        
        // Log analysis to parent portal activity tracker
        function logAnalysisToParent() {
            const clientName = document.getElementById('clientName').value.trim() || 'Unnamed Analysis';
            const iso = document.getElementById('iso').value;
            const zone = document.getElementById('zone').value;
            const startDate = document.getElementById('startDate').value;
            const termMonths = parseInt(document.getElementById('termMonths').value);
            const fixedPrice = parseFloat(document.getElementById('fixedPrice').value);
            const lmpAdjustment = parseFloat(document.getElementById('lmpAdjustment')?.value || 0);
            
            // Get usage data
            const usage = [];
            for (let i = 0; i < 12; i++) {
                usage.push(parseFloat(document.getElementById(`usage_${i}`).value) || 0);
            }
            const totalAnnualUsage = usage.reduce((a, b) => a + b, 0);
            
            // Get results summary
            const lastResult = calculationResults[calculationResults.length - 1];
            const totalIndexCost = lastResult?.cumIndex || 0;
            const totalFixedCost = lastResult?.cumFixed || 0;
            const savingsVsFixed = totalFixedCost - totalIndexCost;
            const totalUsage = calculationResults.reduce((sum, r) => sum + r.usageKwh, 0);
            const avgBlendedRate = totalUsage > 0 ? totalIndexCost / totalUsage : 0;
            
            // Send to parent window for logging
            if (window.parent !== window) {
                window.parent.postMessage({
                    type: 'LMP_ANALYSIS_COMPLETE',
                    data: {
                        clientName: clientName,
                        iso: iso,
                        zone: zone,
                        startDate: startDate,
                        termMonths: termMonths,
                        fixedPrice: fixedPrice,
                        lmpAdjustment: lmpAdjustment,
                        totalAnnualUsage: totalAnnualUsage,
                        results: {
                            totalIndexCost: totalIndexCost,
                            totalFixedCost: totalFixedCost,
                            savingsVsFixed: savingsVsFixed,
                            avgBlendedRate: avgBlendedRate,
                            totalUsage: totalUsage
                        },
                        timestamp: new Date().toISOString()
                    }
                }, '*');
                
                console.log('[LMP Portal] Analysis logged:', clientName);
            }
        }
        
        // Reset form to initial state
        function resetForm() {
            // Clear client name
            document.getElementById('clientName').value = '';
            
            // Reset ISO and Zone to defaults
            document.getElementById('iso').value = 'ISONE';
            updateZoneOptions();
            
            // Reset dates and term
            document.getElementById('startDate').value = '2016-01';
            document.getElementById('termMonths').value = '60';
            
            // Reset pricing
            document.getElementById('fixedPrice').value = '0.085';
            document.getElementById('capacityCost').value = '0.015';
            document.getElementById('ancillaryCost').value = '0.005';
            document.getElementById('transmissionCost').value = '0.012';
            
            // Reset usage to defaults
            const defaultUsage = [850000, 780000, 720000, 680000, 750000, 920000, 1050000, 1020000, 880000, 760000, 700000, 820000];
            for (let i = 0; i < 12; i++) {
                const usageInput = document.getElementById(`usage_${i}`);
                if (usageInput) usageInput.value = defaultUsage[i];
            }
            
            // Reset LMP adjustment slider
            const lmpSlider = document.getElementById('lmpAdjustment');
            if (lmpSlider) {
                lmpSlider.value = 0;
                document.getElementById('lmpAdjustValue').textContent = '+0.0%';
            }
            
            // Reset hedge mode to simple
            document.querySelectorAll('.hedge-mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes('Simple')) btn.classList.add('active');
            });
            document.getElementById('simpleHedgeConfig').style.display = 'block';
            document.getElementById('matrixHedgeConfig').style.display = 'none';
            
            // Reset simple hedge inputs
            document.getElementById('hedgeRate').value = '0.055';
            document.getElementById('hedgePercent').value = '50';
            
            // Clear calculation results
            calculationResults = null;
            projectedMonths = [];
            baseLMPData = [];
            
            // Hide results sections
            document.getElementById('resultsCard').style.display = 'none';
            document.getElementById('lmpSliderCard').style.display = 'none';
            document.getElementById('projectionNotice').style.display = 'none';
            
            // Update term info display
            updateTermInfo();
            
            // Show notification
            showNotification('Form reset to defaults', 'info');
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function displayResults() {
            document.getElementById('resultsCard').style.display = 'block';
            document.getElementById('lmpSliderCard').style.display = 'block';
            
            if (projectedMonths.length > 0) {
                const notice = document.getElementById('projectionNotice');
                notice.style.display = 'block';
                
                const monthList = projectedMonths.map(p => `${p.month} ${p.year}`).join(', ');
                const avgYears = Math.round(projectedMonths.reduce((sum, p) => sum + p.yearsAveraged, 0) / projectedMonths.length);
                const projectionMethod = document.getElementById('projectionMethod').value;
                const escalator = parseFloat(document.getElementById('lmpEscalator').value) || 0;
                
                let escalatorNote = '';
                if (escalator !== 0) {
                    escalatorNote = ` A <strong>${escalator > 0 ? '+' : ''}${escalator}% YoY escalator</strong> has been applied to projected values.`;
                }
                
                document.getElementById('projectionMessage').innerHTML = 
                    `<strong>Projected LMP values used for:</strong> ${monthList}. ` +
                    `These values are calculated using a <strong>${projectionMethod}-year rolling average</strong> of the same month over the preceding ${avgYears} year${avgYears > 1 ? 's' : ''} ` +
                    `and are marked with a <span class="projected-badge">PROJECTED</span> badge in the detailed table.${escalatorNote}`;
            } else {
                document.getElementById('projectionNotice').style.display = 'none';
            }
            
            const lastResult = calculationResults[calculationResults.length - 1];
            const totalIndexCost = lastResult.cumIndex;
            const totalFixedCost = lastResult.cumFixed;
            const savingsVsFixed = totalFixedCost - totalIndexCost;
            
            const totalUsage = calculationResults.reduce((sum, r) => sum + r.usageKwh, 0);
            const avgBlendedRate = totalIndexCost / totalUsage;
            
            const summaryHTML = `
                <div class="summary-card">
                    <div class="summary-label">Total Index Cost</div>
                    <div class="summary-value">$${totalIndexCost.toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                </div>
                <div class="summary-card">
                    <div class="summary-label">Total Fixed Cost</div>
                    <div class="summary-value">$${totalFixedCost.toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                </div>
                <div class="summary-card ${savingsVsFixed > 0 ? 'success' : 'warning'}">
                    <div class="summary-label">Savings vs Fixed</div>
                    <div class="summary-value ${savingsVsFixed >= 0 ? 'positive-value' : 'negative-value'}">
                        ${savingsVsFixed >= 0 ? '+' : ''}$${savingsVsFixed.toLocaleString(undefined, {maximumFractionDigits: 0})}
                    </div>
                </div>
                <div class="summary-card">
                    <div class="summary-label">Avg Blended Rate</div>
                    <div class="summary-value small-text">$${avgBlendedRate.toFixed(5)}/kWh</div>
                </div>
            `;
            document.getElementById('summaryCards').innerHTML = summaryHTML;
            
            renderAllCharts();
            renderDetailedTable();
            renderYearlyTable();
            
            // Scroll to LMP slider (just above results)
            document.getElementById('lmpSliderCard').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            
            const tabMap = {
                'overview': 'overviewTab',
                'breakdown': 'breakdownTab',
                'yearly': 'yearlyTab',
                'monthly': 'monthlyDetailTab'
            };
            
            document.getElementById(tabMap[tabName]).classList.add('active');
        }

        function toggleCumulativeView(mode) {
            cumulativeViewMode = mode;
            document.querySelectorAll('#overviewTab .chart-container:first-child .view-toggle-btn')
                .forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            renderCumulativeChart();
        }

        function toggleMonthlyView(mode) {
            monthlyViewMode = mode;
            document.querySelectorAll('#overviewTab .chart-container:nth-child(2) .view-toggle-btn')
                .forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            renderMonthlyChart();
        }

        function toggleYearlyView(mode) {
            yearlyViewMode = mode;
            document.querySelectorAll('#yearlyTab .view-toggle-btn')
                .forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            renderYearlyChart();
        }

        function toggleMonthByMonthView(mode) {
            monthByMonthViewMode = mode;
            document.querySelectorAll('#monthlyDetailTab .view-toggle-btn')
                .forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            renderMonthByMonthChart();
        }

        function toggleCumulativeChart(type) {
            cumulativeChartType = type;
            document.querySelectorAll('#overviewTab .chart-container:first-child .chart-toggle .chart-toggle-btn')
                .forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            renderCumulativeChart();
        }

        function toggleMonthlyChart(type) {
            monthlyChartType = type;
            document.querySelectorAll('#overviewTab .chart-container:nth-child(2) .chart-toggle .chart-toggle-btn')
                .forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            renderMonthlyChart();
        }

        function renderAllCharts() {
            renderCumulativeChart();
            renderMonthlyChart();
            renderPieChart();
            renderYearlyChart();
            renderMonthByMonthChart();
        }

        function renderCumulativeChart() {
            const ctx = document.getElementById('cumulativeChart');
            if (cumulativeChart) cumulativeChart.destroy();
            
            let indexData, fixedData, yLabel;
            
            if (cumulativeViewMode === 'cost') {
                indexData = calculationResults.map(r => r.cumIndex);
                fixedData = calculationResults.map(r => r.cumFixed);
                yLabel = 'Total Cost ($)';
            } else {
                indexData = calculationResults.map(r => r.cumIndex / r.cumUsage);
                fixedData = calculationResults.map(r => r.fixedRate);
                yLabel = 'Average Rate ($/kWh)';
            }
            
            cumulativeChart = new Chart(ctx, {
                type: cumulativeChartType,
                data: {
                    labels: calculationResults.map(r => `${r.monthShort} ${r.actualYear}`),
                    datasets: [
                        {
                            label: 'Index (with Hedge)',
                            data: indexData,
                            borderColor: '#0d9488',
                            backgroundColor: cumulativeChartType === 'line' ? 
                                'rgba(13, 148, 136, 0.1)' : 'rgba(13, 148, 136, 0.8)',
                            borderWidth: 3,
                            tension: 0.4,
                            fill: cumulativeChartType === 'line'
                        },
                        {
                            label: 'Fixed',
                            data: fixedData,
                            borderColor: '#f59e0b',
                            backgroundColor: cumulativeChartType === 'line' ? 
                                'rgba(245, 158, 11, 0.1)' : 'rgba(245, 158, 11, 0.8)',
                            borderWidth: 3,
                            tension: 0.4,
                            fill: cumulativeChartType === 'line'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (cumulativeViewMode === 'cost') {
                                        return context.dataset.label + ': $' + 
                                               context.parsed.y.toLocaleString(undefined, {maximumFractionDigits: 0});
                                    } else {
                                        return context.dataset.label + ': $' + 
                                               context.parsed.y.toFixed(5) + '/kWh';
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: yLabel
                            },
                            ticks: {
                                callback: function(value) {
                                    if (cumulativeViewMode === 'cost') {
                                        return '$' + (value/1000).toFixed(0) + 'k';
                                    } else {
                                        return '$' + value.toFixed(3);
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderMonthlyChart() {
            const ctx = document.getElementById('monthlyChart');
            if (monthlyChart) monthlyChart.destroy();
            
            let indexData, fixedData, yLabel;
            
            if (monthlyViewMode === 'cost') {
                indexData = calculationResults.map(r => r.indexCost);
                fixedData = calculationResults.map(r => r.fixedCost);
                yLabel = 'Monthly Cost ($)';
            } else {
                indexData = calculationResults.map(r => r.indexRate);
                fixedData = calculationResults.map(r => r.fixedRate);
                yLabel = 'Rate ($/kWh)';
            }
            
            monthlyChart = new Chart(ctx, {
                type: monthlyChartType,
                data: {
                    labels: calculationResults.map(r => `${r.monthShort} ${r.actualYear}`),
                    datasets: [
                        {
                            label: 'Index (with Hedge)',
                            data: indexData,
                            backgroundColor: monthlyChartType === 'bar' ? 
                                'rgba(13, 148, 136, 0.8)' : 'rgba(13, 148, 136, 0.2)',
                            borderColor: '#0d9488',
                            borderWidth: monthlyChartType === 'line' ? 3 : 2,
                            tension: 0.4,
                            fill: monthlyChartType === 'line'
                        },
                        {
                            label: 'Fixed',
                            data: fixedData,
                            backgroundColor: monthlyChartType === 'bar' ? 
                                'rgba(245, 158, 11, 0.8)' : 'rgba(245, 158, 11, 0.2)',
                            borderColor: '#f59e0b',
                            borderWidth: monthlyChartType === 'line' ? 3 : 2,
                            tension: 0.4,
                            fill: monthlyChartType === 'line'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (monthlyViewMode === 'cost') {
                                        return context.dataset.label + ': $' + 
                                               context.parsed.y.toLocaleString(undefined, {maximumFractionDigits: 0});
                                    } else {
                                        return context.dataset.label + ': $' + 
                                               context.parsed.y.toFixed(5) + '/kWh';
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: yLabel
                            },
                            ticks: {
                                callback: function(value) {
                                    if (monthlyViewMode === 'cost') {
                                        return '$' + (value/1000).toFixed(0) + 'k';
                                    } else {
                                        return '$' + value.toFixed(3);
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderPieChart() {
            const ctx = document.getElementById('pieChart');
            if (pieChart) pieChart.destroy();
            
            const totals = calculationResults.reduce((acc, r) => {
                acc.capacity += r.capacityCost;
                acc.transmission += r.transmissionCost;
                acc.ancillary += r.ancillaryCost;
                acc.openEnergy += r.openEnergyCost;
                acc.hedgedEnergy += r.hedgedEnergyCost;
                return acc;
            }, { capacity: 0, transmission: 0, ancillary: 0, openEnergy: 0, hedgedEnergy: 0 });
            
            pieChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Capacity', 'Transmission', 'Ancillary Services', 'Index Energy (Open)', 'Hedged Energy (Fixed Block)'],
                    datasets: [{
                        data: [
                            totals.capacity,
                            totals.transmission,
                            totals.ancillary,
                            totals.openEnergy,
                            totals.hedgedEnergy
                        ],
                        backgroundColor: [
                            '#0d9488',
                            '#065f46',
                            '#10b981',
                            '#f59e0b',
                            '#3b82f6'
                        ],
                        borderWidth: 3,
                        borderColor: '#ffffff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            position: 'right',
                            labels: {
                                padding: 15,
                                font: {
                                    size: 13,
                                    weight: '600'
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                                    return context.label + ': $' + 
                                           context.parsed.toLocaleString(undefined, {maximumFractionDigits: 0}) +
                                           ' (' + percentage + '%)';
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderYearlyChart() {
            const ctx = document.getElementById('yearlyChart');
            if (yearlyChart) yearlyChart.destroy();
            
            const yearlyData = {};
            calculationResults.forEach(r => {
                const year = r.actualYear;
                if (!yearlyData[year]) {
                    yearlyData[year] = { index: 0, fixed: 0, usage: 0 };
                }
                yearlyData[year].index += r.indexCost;
                yearlyData[year].fixed += r.fixedCost;
                yearlyData[year].usage += r.usageKwh;
            });
            
            const years = Object.keys(yearlyData).sort();
            
            let indexData, fixedData, yLabel;
            
            if (yearlyViewMode === 'cost') {
                indexData = years.map(y => yearlyData[y].index);
                fixedData = years.map(y => yearlyData[y].fixed);
                yLabel = 'Annual Cost ($)';
            } else {
                indexData = years.map(y => yearlyData[y].index / yearlyData[y].usage);
                fixedData = years.map(y => yearlyData[y].fixed / yearlyData[y].usage);
                yLabel = 'Average Rate ($/kWh)';
            }
            
            yearlyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: years,
                    datasets: [
                        {
                            label: 'Index Cost',
                            data: indexData,
                            backgroundColor: 'rgba(13, 148, 136, 0.8)',
                            borderColor: '#0d9488',
                            borderWidth: 2
                        },
                        {
                            label: 'Fixed Cost',
                            data: fixedData,
                            backgroundColor: 'rgba(245, 158, 11, 0.8)',
                            borderColor: '#f59e0b',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (yearlyViewMode === 'cost') {
                                        return context.dataset.label + ': $' + 
                                               context.parsed.y.toLocaleString(undefined, {maximumFractionDigits: 0});
                                    } else {
                                        return context.dataset.label + ': $' + 
                                               context.parsed.y.toFixed(5) + '/kWh';
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: yLabel
                            },
                            ticks: {
                                callback: function(value) {
                                    if (yearlyViewMode === 'cost') {
                                        return '$' + (value/1000).toFixed(0) + 'k';
                                    } else {
                                        return '$' + value.toFixed(3);
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderMonthByMonthChart() {
            const ctx = document.getElementById('monthByMonthChart');
            if (monthByMonthChart) monthByMonthChart.destroy();
            
            const monthlyData = {};
            for (let m = 0; m < 12; m++) {
                monthlyData[m] = { index: 0, fixed: 0, usage: 0, count: 0 };
            }
            
            calculationResults.forEach(r => {
                const m = r.monthNum;
                monthlyData[m].index += r.indexCost;
                monthlyData[m].fixed += r.fixedCost;
                monthlyData[m].usage += r.usageKwh;
                monthlyData[m].count++;
            });
            
            let avgIndex, avgFixed, yLabel;
            
            if (monthByMonthViewMode === 'cost') {
                avgIndex = [];
                avgFixed = [];
                for (let m = 0; m < 12; m++) {
                    avgIndex.push(monthlyData[m].index / monthlyData[m].count);
                    avgFixed.push(monthlyData[m].fixed / monthlyData[m].count);
                }
                yLabel = 'Average Monthly Cost ($)';
            } else {
                avgIndex = [];
                avgFixed = [];
                for (let m = 0; m < 12; m++) {
                    avgIndex.push(monthlyData[m].index / monthlyData[m].usage);
                    avgFixed.push(monthlyData[m].fixed / monthlyData[m].usage);
                }
                yLabel = 'Average Rate ($/kWh)';
            }
            
            monthByMonthChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: monthsFull,
                    datasets: [
                        {
                            label: 'Avg Index Cost',
                            data: avgIndex,
                            backgroundColor: 'rgba(13, 148, 136, 0.8)',
                            borderColor: '#0d9488',
                            borderWidth: 2
                        },
                        {
                            label: 'Avg Fixed Cost',
                            data: avgFixed,
                            backgroundColor: 'rgba(245, 158, 11, 0.8)',
                            borderColor: '#f59e0b',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top' },
                        title: {
                            display: true,
                            text: 'Average by Month (Across All Contract Years)'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (monthByMonthViewMode === 'cost') {
                                        return context.dataset.label + ': $' + 
                                               context.parsed.y.toLocaleString(undefined, {maximumFractionDigits: 0});
                                    } else {
                                        return context.dataset.label + ': $' + 
                                               context.parsed.y.toFixed(5) + '/kWh';
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: yLabel
                            },
                            ticks: {
                                callback: function(value) {
                                    if (monthByMonthViewMode === 'cost') {
                                        return '$' + (value/1000).toFixed(0) + 'k';
                                    } else {
                                        return '$' + value.toFixed(3);
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderYearlyTable() {
            const yearlyData = {};
            calculationResults.forEach(r => {
                const year = r.actualYear;
                if (!yearlyData[year]) {
                    yearlyData[year] = { 
                        index: 0, fixed: 0, usage: 0,
                        capacity: 0, ancillary: 0, transmission: 0,
                        openEnergy: 0, hedgedEnergy: 0
                    };
                }
                yearlyData[year].index += r.indexCost;
                yearlyData[year].fixed += r.fixedCost;
                yearlyData[year].usage += r.usageKwh;
                yearlyData[year].capacity += r.capacityCost;
                yearlyData[year].ancillary += r.ancillaryCost;
                yearlyData[year].transmission += r.transmissionCost;
                yearlyData[year].openEnergy += r.openEnergyCost;
                yearlyData[year].hedgedEnergy += r.hedgedEnergyCost;
            });
            
            const years = Object.keys(yearlyData).sort();
            
            let html = `
                <thead>
                    <tr>
                        <th>Year</th>
                        <th>Usage (kWh)</th>
                        <th>Capacity</th>
                        <th>Trans+Anc</th>
                        <th>Open Energy</th>
                        <th>Hedged Energy</th>
                        <th>Total Index</th>
                        <th>Total Fixed</th>
                        <th>Savings</th>
                        <th>Avg Rate</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            years.forEach(year => {
                const data = yearlyData[year];
                const savings = data.fixed - data.index;
                const avgRate = data.index / data.usage;
                html += `
                    <tr>
                        <td><strong>${year}</strong></td>
                        <td>${data.usage.toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td>$${data.capacity.toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td>$${(data.transmission + data.ancillary).toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td>$${data.openEnergy.toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td>$${data.hedgedEnergy.toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td>$${data.index.toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td>$${data.fixed.toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td class="${savings >= 0 ? 'positive-value' : 'negative-value'}">
                            ${savings >= 0 ? '+' : ''}$${savings.toLocaleString(undefined, {maximumFractionDigits: 0})}
                        </td>
                        <td>$${avgRate.toFixed(5)}</td>
                    </tr>
                `;
            });
            
            html += '</tbody>';
            document.getElementById('yearlyTable').innerHTML = html;
        }

        function renderDetailedTable() {
            let html = `
                <thead>
                    <tr>
                        <th>Period</th>
                        <th>Month</th>
                        <th>Year</th>
                        <th>Usage (kWh)</th>
                        <th>LMP</th>
                        <th>Hedge %</th>
                        <th>Block Rate</th>
                        <th>Blended Rate</th>
                        <th>Capacity</th>
                        <th>Trans+Anc</th>
                        <th>Index Cost</th>
                        <th>Fixed Cost</th>
                        <th>vs Fixed</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            calculationResults.forEach((r, idx) => {
                const diff = r.fixedCost - r.indexCost;
                const projectedBadge = r.isProjected ? '<span class="projected-badge">PROJECTED</span>' : '';
                html += `
                    <tr onmouseenter="showBillTooltip(event, ${idx})" onmouseleave="hideBillTooltip()">
                        <td>${r.period}</td>
                        <td>${r.month}</td>
                        <td>${r.actualYear}</td>
                        <td>${r.usageKwh.toLocaleString()}</td>
                        <td>$${r.lmp.toFixed(4)} ${projectedBadge}</td>
                        <td>${r.hedgePercent.toFixed(0)}%</td>
                        <td>$${r.blockRate.toFixed(4)}</td>
                        <td>$${r.blendedRate.toFixed(4)}</td>
                        <td>$${r.capacityCost.toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td>$${(r.ancillaryCost + r.transmissionCost).toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td>$${r.indexCost.toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td>$${r.fixedCost.toLocaleString(undefined, {maximumFractionDigits: 0})}</td>
                        <td class="${diff >= 0 ? 'positive-value' : 'negative-value'}">
                            ${diff >= 0 ? '+' : ''}$${diff.toLocaleString(undefined, {maximumFractionDigits: 0})}
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody>';
            document.getElementById('detailedTable').innerHTML = html;
        }

        // BILL TOOLTIP FUNCTIONS
        function showBillTooltip(event, rowIndex) {
            const r = calculationResults[rowIndex];
            const tooltip = document.getElementById('billTooltip');
            
            const billHTML = `
                <div class="bill-header">
                    <h3>‚ö° Energy Supply Bill Breakdown</h3>
                    <p>${r.month} ${r.actualYear} ‚Ä¢ ${r.usageKwh.toLocaleString()} kWh</p>
                </div>
                
                <div class="bill-section">
                    <div class="bill-section-title">Non-Energy Charges</div>
                    <div class="bill-line">
                        <span class="bill-line-label">
                            <span class="bill-indicator indicator-capacity"></span>
                            Capacity
                            <span class="bill-line-rate">@$${r.capacityRate.toFixed(5)}/kWh</span>
                        </span>
                        <span class="bill-line-value">$${r.capacityCost.toLocaleString(undefined, {maximumFractionDigits: 2})}</span>
                    </div>
                    <div class="bill-line">
                        <span class="bill-line-label">
                            <span class="bill-indicator indicator-transmission"></span>
                            Transmission
                            <span class="bill-line-rate">@$${r.transmissionRate.toFixed(5)}/kWh</span>
                        </span>
                        <span class="bill-line-value">$${r.transmissionCost.toLocaleString(undefined, {maximumFractionDigits: 2})}</span>
                    </div>
                    <div class="bill-line">
                        <span class="bill-line-label">
                            <span class="bill-indicator indicator-ancillary"></span>
                            Ancillary Services
                            <span class="bill-line-rate">@$${r.ancillaryRate.toFixed(5)}/kWh</span>
                        </span>
                        <span class="bill-line-value">$${r.ancillaryCost.toLocaleString(undefined, {maximumFractionDigits: 2})}</span>
                    </div>
                    <div class="bill-line bill-subtotal">
                        <span class="bill-line-label">Non-Energy Subtotal</span>
                        <span class="bill-line-value">$${(r.capacityCost + r.transmissionCost + r.ancillaryCost).toLocaleString(undefined, {maximumFractionDigits: 2})}</span>
                    </div>
                </div>
                
                <div class="bill-section">
                    <div class="bill-section-title">Energy Charges</div>
                    ${r.openEnergyCost > 0 ? `
                    <div class="bill-line">
                        <span class="bill-line-label">
                            <span class="bill-indicator indicator-open"></span>
                            Index Energy (${r.openPercent.toFixed(0)}% Open)
                            <span class="bill-line-rate">@$${r.openEnergyRate.toFixed(5)}/kWh</span>
                        </span>
                        <span class="bill-line-value">$${r.openEnergyCost.toLocaleString(undefined, {maximumFractionDigits: 2})}</span>
                    </div>
                    ` : ''}
                    ${r.hedgedEnergyCost > 0 ? `
                    <div class="bill-line">
                        <span class="bill-line-label">
                            <span class="bill-indicator indicator-hedged"></span>
                            Hedged Energy (${r.hedgePercent.toFixed(0)}% Hedged)
                            <span class="bill-line-rate">@$${r.hedgedEnergyRate.toFixed(5)}/kWh</span>
                        </span>
                        <span class="bill-line-value">$${r.hedgedEnergyCost.toLocaleString(undefined, {maximumFractionDigits: 2})}</span>
                    </div>
                    ` : ''}
                    ${r.openEnergyCost === 0 && r.hedgedEnergyCost === 0 ? `
                    <div class="bill-line">
                        <span class="bill-line-label">
                            <span class="bill-indicator indicator-open"></span>
                            Energy (100% Index)
                            <span class="bill-line-rate">@$${r.lmpWithLineLoss.toFixed(5)}/kWh</span>
                        </span>
                        <span class="bill-line-value">$${(r.lmpWithLineLoss * r.usageKwh).toLocaleString(undefined, {maximumFractionDigits: 2})}</span>
                    </div>
                    ` : ''}
                    <div class="bill-line bill-subtotal">
                        <span class="bill-line-label">Energy Subtotal</span>
                        <span class="bill-line-value">$${(r.openEnergyCost + r.hedgedEnergyCost).toLocaleString(undefined, {maximumFractionDigits: 2})}</span>
                    </div>
                </div>
                
                <div class="bill-total">
                    <span class="bill-total-label">Total Supply Charges</span>
                    <span class="bill-total-value">$${r.indexCost.toLocaleString(undefined, {maximumFractionDigits: 2})}</span>
                </div>
                
                <div style="margin-top: 15px; padding-top: 15px; border-top: 2px solid #e5e7eb;">
                    <div class="bill-line" style="font-size: 14px; font-weight: 600;">
                        <span class="bill-line-label" style="color: #0d9488;">Effective Rate (All-In)</span>
                        <span class="bill-line-value" style="color: #065f46; font-size: 16px;">$${r.indexRate.toFixed(5)}/kWh</span>
                    </div>
                </div>
            `;
            
            tooltip.innerHTML = billHTML;
            tooltip.classList.add('show');
            
            // Small delay to ensure DOM has updated with content
            setTimeout(() => {
                // Get tooltip dimensions after content is rendered
                const tooltipRect = tooltip.getBoundingClientRect();
                const tooltipWidth = tooltipRect.width;
                const tooltipHeight = tooltipRect.height;
                
                // Get viewport dimensions
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Calculate initial position (offset from cursor)
                let x = event.clientX + 20;
                let y = event.clientY + 20;
                
                // Check right edge - if tooltip would go off screen, position to left of cursor
                if (x + tooltipWidth > viewportWidth - 20) {
                    x = event.clientX - tooltipWidth - 20;
                }
                
                // Check left edge - ensure tooltip doesn't go off left side
                if (x < 20) {
                    x = 20;
                }
                
                // Check bottom edge - if tooltip would go off screen, position above cursor
                if (y + tooltipHeight > viewportHeight - 20) {
                    y = event.clientY - tooltipHeight - 20;
                }
                
                // Check top edge - ensure tooltip doesn't go off top
                if (y < 20) {
                    y = 20;
                }
                
                // Apply final position
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }, 10);
        }

        function hideBillTooltip() {
            const tooltip = document.getElementById('billTooltip');
            tooltip.classList.remove('show');
        }

        function exportToExcel() {
            if (!calculationResults) {
                alert('Please calculate results first');
                return;
            }
            
            const wb = XLSX.utils.book_new();
            
            const monthlyData = [
                ['Energy Procurement Analysis - Secure Energy'],
                ['Monthly Breakdown'],
                [],
                ['Period', 'Month', 'Year', 'Usage (kWh)', 'LMP', 'Projected', 'LMP w/ Loss', 'Hedge %', 'Block Rate', 
                 'Block w/ Loss', 'Blended Rate', 'Capacity', 'Ancillary', 'Transmission', 
                 'Open Energy', 'Hedged Energy', 'Index Cost', 'Fixed Cost', 'Savings vs Fixed']
            ];
            
            calculationResults.forEach(r => {
                monthlyData.push([
                    r.period,
                    r.month,
                    r.actualYear,
                    r.usageKwh,
                    r.lmp,
                    r.isProjected ? 'YES' : 'NO',
                    r.lmpWithLineLoss,
                    r.hedgePercent / 100,
                    r.blockRate,
                    r.blockRateWithLineLoss,
                    r.blendedRate,
                    r.capacityCost,
                    r.ancillaryCost,
                    r.transmissionCost,
                    r.openEnergyCost,
                    r.hedgedEnergyCost,
                    r.indexCost,
                    r.fixedCost,
                    r.fixedCost - r.indexCost
                ]);
            });
            
            const ws1 = XLSX.utils.aoa_to_sheet(monthlyData);
            ws1['!cols'] = Array(19).fill({wch: 12});
            XLSX.utils.book_append_sheet(wb, ws1, 'Monthly Detail');
            
            const yearlyData = {};
            calculationResults.forEach(r => {
                const year = r.actualYear;
                if (!yearlyData[year]) {
                    yearlyData[year] = { index: 0, fixed: 0, usage: 0, capacity: 0, ancillary: 0, transmission: 0 };
                }
                yearlyData[year].index += r.indexCost;
                yearlyData[year].fixed += r.fixedCost;
                yearlyData[year].usage += r.usageKwh;
                yearlyData[year].capacity += r.capacityCost;
                yearlyData[year].ancillary += r.ancillaryCost;
                yearlyData[year].transmission += r.transmissionCost;
            });
            
            const yearlySheet = [
                ['Year Over Year Summary'],
                [],
                ['Year', 'Total Usage', 'Capacity', 'Ancillary', 'Transmission', 'Index Cost', 'Fixed Cost', 'Savings', 'Avg Rate']
            ];
            
            Object.keys(yearlyData).sort().forEach(year => {
                const data = yearlyData[year];
                yearlySheet.push([
                    year,
                    data.usage,
                    data.capacity,
                    data.ancillary,
                    data.transmission,
                    data.index,
                    data.fixed,
                    data.fixed - data.index,
                    data.index / data.usage
                ]);
            });
            
            const ws2 = XLSX.utils.aoa_to_sheet(yearlySheet);
            ws2['!cols'] = Array(9).fill({wch: 14});
            XLSX.utils.book_append_sheet(wb, ws2, 'Year Over Year');
            
            XLSX.writeFile(wb, 'energy-procurement-analysis.xlsx');
        }

        // POWERPOINT EXPORT FUNCTION
        async function exportToPowerPoint() {
            if (!calculationResults) {
                alert('Please calculate results first');
                return;
            }

            const pptx = new PptxGenJS();
            pptx.layout = 'LAYOUT_16x9';
            pptx.author = 'Secure Energy Solutions';
            pptx.company = 'Secure Energy Solutions';
            pptx.subject = 'Index Energy Cost Modeling Analysis';
            pptx.title = 'Energy Procurement Analysis';

            // Brand colors
            const colors = {
                primary: '0d9488',
                secondary: '065f46',
                accent: '10b981',
                dark: '1f2937',
                gray: '6b7280',
                light: 'f3f4f6',
                white: 'ffffff',
                amber: 'f59e0b',
                blue: '3b82f6'
            };

            // Calculate summary data
            const lastResult = calculationResults[calculationResults.length - 1];
            const totalIndexCost = lastResult.cumIndex;
            const totalFixedCost = lastResult.cumFixed;
            const savingsVsFixed = totalFixedCost - totalIndexCost;
            const totalUsage = calculationResults.reduce((sum, r) => sum + r.usageKwh, 0);
            const avgBlendedRate = totalIndexCost / totalUsage;

            // Get settings
            const iso = document.getElementById('iso').value;
            const zone = document.getElementById('zone').value;
            const startDate = document.getElementById('startDate').value;
            const termMonths = parseInt(document.getElementById('termMonths').value);
            const fixedPrice = parseFloat(document.getElementById('fixedPrice').value);
            const lmpAdjustment = parseFloat(document.getElementById('lmpAdjustSlider').value);

            // SLIDE 1: Title Slide
            let slide = pptx.addSlide();
            slide.background = { color: colors.primary };
            
            slide.addText('Index Energy Cost Modeling', {
                x: 0.5, y: 1.5, w: 9, h: 1,
                fontSize: 44, bold: true, color: colors.white,
                align: 'center'
            });
            
            slide.addText('Analysis Report', {
                x: 0.5, y: 2.5, w: 9, h: 0.6,
                fontSize: 32, color: colors.white,
                align: 'center'
            });
            
            slide.addText([
                { text: iso + ' | ' + zone + '\n', options: { fontSize: 18, color: colors.white } },
                { text: new Date().toLocaleDateString(), options: { fontSize: 16, color: 'e0e0e0' } }
            ], {
                x: 0.5, y: 4.2, w: 9, h: 0.8,
                align: 'center'
            });

            // SLIDE 2: Executive Summary
            slide = pptx.addSlide();
            slide.addText('Executive Summary', {
                x: 0.5, y: 0.4, w: 9, h: 0.6,
                fontSize: 36, bold: true, color: colors.primary
            });

            const summaryData = [
                ['Metric', 'Value'],
                ['Contract Term', `${termMonths} months (${startDate})`],
                ['Total Usage', `${totalUsage.toLocaleString()} kWh`],
                ['Total Index Cost', `$${totalIndexCost.toLocaleString(undefined, {maximumFractionDigits: 0})}`],
                ['Total Fixed Cost', `$${totalFixedCost.toLocaleString(undefined, {maximumFractionDigits: 0})}`],
                ['Savings vs Fixed', `${savingsVsFixed >= 0 ? '+' : ''}$${savingsVsFixed.toLocaleString(undefined, {maximumFractionDigits: 0})}`],
                ['Avg Blended Rate', `$${avgBlendedRate.toFixed(5)}/kWh`],
                ['Fixed Price', `$${fixedPrice.toFixed(5)}/kWh`],
                ['LMP Adjustment', `${lmpAdjustment >= 0 ? '+' : ''}${lmpAdjustment.toFixed(1)}%`]
            ];

            slide.addTable(summaryData, {
                x: 1.0, y: 1.3, w: 8, h: 3.5,
                fontSize: 16,
                color: colors.dark,
                fill: { color: colors.light },
                border: { pt: 1, color: colors.gray },
                rowH: 0.4,
                colW: [3.5, 4.5],
                valign: 'middle',
                align: 'left'
            });

            // SLIDE 3: Cost Breakdown Pie Chart
            slide = pptx.addSlide();
            slide.addText('Cost Component Breakdown', {
                x: 0.5, y: 0.4, w: 9, h: 0.6,
                fontSize: 36, bold: true, color: colors.primary
            });

            const totals = calculationResults.reduce((acc, r) => {
                acc.capacity += r.capacityCost;
                acc.transmission += r.transmissionCost;
                acc.ancillary += r.ancillaryCost;
                acc.openEnergy += r.openEnergyCost;
                acc.hedgedEnergy += r.hedgedEnergyCost;
                return acc;
            }, { capacity: 0, transmission: 0, ancillary: 0, openEnergy: 0, hedgedEnergy: 0 });

            const pieData = [
                {
                    name: 'Cost Components',
                    labels: ['Capacity', 'Transmission', 'Ancillary', 'Index Energy', 'Hedged Energy'],
                    values: [totals.capacity, totals.transmission, totals.ancillary, totals.openEnergy, totals.hedgedEnergy]
                }
            ];

            slide.addChart(pptx.ChartType.pie, pieData, {
                x: 1.5, y: 1.3, w: 7, h: 4,
                showLegend: true,
                legendPos: 'r',
                chartColors: [colors.primary, colors.secondary, colors.accent, colors.amber, colors.blue],
                dataLabelColor: colors.white,
                dataLabelFontSize: 12,
                showValue: true,
                showPercent: true
            });

            // SLIDE 4: Cumulative Cost Comparison
            slide = pptx.addSlide();
            slide.addText('Cumulative Cost Comparison', {
                x: 0.5, y: 0.4, w: 9, h: 0.6,
                fontSize: 36, bold: true, color: colors.primary
            });

            const labels = calculationResults.map(r => `${r.monthShort} ${r.actualYear}`);
            const indexCumData = calculationResults.map(r => r.cumIndex);
            const fixedCumData = calculationResults.map(r => r.cumFixed);

            const cumulativeData = [
                {
                    name: 'Index (with Hedge)',
                    labels: labels,
                    values: indexCumData
                },
                {
                    name: 'Fixed',
                    labels: labels,
                    values: fixedCumData
                }
            ];

            slide.addChart(pptx.ChartType.line, cumulativeData, {
                x: 0.5, y: 1.3, w: 9, h: 4,
                showLegend: true,
                legendPos: 't',
                chartColors: [colors.primary, colors.amber],
                lineSize: 3,
                lineSmooth: true,
                valAxisMaxVal: Math.max(...fixedCumData) * 1.1,
                showValue: false,
                catAxisLabelFontSize: 8,
                valAxisLabelFontSize: 10
            });

            // SLIDE 5: Year Over Year Comparison
            slide = pptx.addSlide();
            slide.addText('Year Over Year Analysis', {
                x: 0.5, y: 0.4, w: 9, h: 0.6,
                fontSize: 36, bold: true, color: colors.primary
            });

            const yearlyData = {};
            calculationResults.forEach(r => {
                const year = r.actualYear;
                if (!yearlyData[year]) {
                    yearlyData[year] = { index: 0, fixed: 0 };
                }
                yearlyData[year].index += r.indexCost;
                yearlyData[year].fixed += r.fixedCost;
            });

            const years = Object.keys(yearlyData).sort();
            const yearlyChartData = [
                {
                    name: 'Index Cost',
                    labels: years,
                    values: years.map(y => yearlyData[y].index)
                },
                {
                    name: 'Fixed Cost',
                    labels: years,
                    values: years.map(y => yearlyData[y].fixed)
                }
            ];

            slide.addChart(pptx.ChartType.bar, yearlyChartData, {
                x: 0.5, y: 1.3, w: 9, h: 4,
                showLegend: true,
                legendPos: 't',
                chartColors: [colors.primary, colors.amber],
                barDir: 'col',
                barGrouping: 'clustered',
                showValue: false,
                valAxisMaxVal: Math.max(...years.map(y => yearlyData[y].fixed)) * 1.1
            });

            // SLIDE 6: Monthly Detail Table (First 18 months)
            slide = pptx.addSlide();
            slide.addText('Monthly Detail - First 18 Months', {
                x: 0.5, y: 0.4, w: 9, h: 0.6,
                fontSize: 36, bold: true, color: colors.primary
            });

            const detailRows = [
                [
                    { text: 'Month', options: { bold: true, color: colors.white } },
                    { text: 'Year', options: { bold: true, color: colors.white } },
                    { text: 'Usage (kWh)', options: { bold: true, color: colors.white } },
                    { text: 'LMP', options: { bold: true, color: colors.white } },
                    { text: 'Index Cost', options: { bold: true, color: colors.white } },
                    { text: 'Fixed Cost', options: { bold: true, color: colors.white } },
                    { text: 'Savings', options: { bold: true, color: colors.white } }
                ]
            ];

            calculationResults.slice(0, 18).forEach(r => {
                const diff = r.fixedCost - r.indexCost;
                detailRows.push([
                    r.month.substring(0, 3),
                    r.actualYear.toString(),
                    r.usageKwh.toLocaleString(undefined, {maximumFractionDigits: 0}),
                    '$' + r.lmp.toFixed(4),
                    '$' + r.indexCost.toLocaleString(undefined, {maximumFractionDigits: 0}),
                    '$' + r.fixedCost.toLocaleString(undefined, {maximumFractionDigits: 0}),
                    { 
                        text: (diff >= 0 ? '+$' : '-$') + Math.abs(diff).toLocaleString(undefined, {maximumFractionDigits: 0}),
                        options: { color: diff >= 0 ? '10b981' : 'ef4444', bold: true }
                    }
                ]);
            });

            slide.addTable(detailRows, {
                x: 0.3, y: 1.2, w: 9.4, h: 4.2,
                fontSize: 10,
                border: { pt: 1, color: colors.gray },
                fill: { color: colors.primary },
                color: colors.dark,
                rowH: 0.22,
                valign: 'middle',
                align: 'center',
                autoPage: false
            });

            // SLIDE 7: Key Findings & Recommendations
            slide = pptx.addSlide();
            slide.addText('Key Findings', {
                x: 0.5, y: 0.4, w: 9, h: 0.6,
                fontSize: 36, bold: true, color: colors.primary
            });

            const savingsPercent = ((savingsVsFixed / totalFixedCost) * 100).toFixed(1);
            const recommendation = savingsVsFixed > 0 ? 
                `Index strategy with hedge provides ${savingsPercent}% savings compared to fixed pricing` :
                `Fixed pricing is ${Math.abs(parseFloat(savingsPercent))}% more economical than index strategy`;

            const findings = [
                { text: '‚Ä¢ ', options: { bullet: { code: '2022', color: colors.primary }, fontSize: 20 } },
                { text: `Total Contract Value: $${totalIndexCost.toLocaleString(undefined, {maximumFractionDigits: 0})}\n\n`, options: { fontSize: 20 } },
                { text: '‚Ä¢ ', options: { bullet: { code: '2022', color: colors.primary }, fontSize: 20 } },
                { text: `Savings vs Fixed: ${savingsVsFixed >= 0 ? '+' : ''}$${savingsVsFixed.toLocaleString(undefined, {maximumFractionDigits: 0})}\n\n`, options: { fontSize: 20, color: savingsVsFixed >= 0 ? '10b981' : 'ef4444', bold: true } },
                { text: '‚Ä¢ ', options: { bullet: { code: '2022', color: colors.primary }, fontSize: 20 } },
                { text: `Average Blended Rate: $${avgBlendedRate.toFixed(5)}/kWh\n\n`, options: { fontSize: 20 } },
                { text: '‚Ä¢ ', options: { bullet: { code: '2022', color: colors.primary }, fontSize: 20 } },
                { text: `LMP Scenario: ${lmpAdjustment >= 0 ? '+' : ''}${lmpAdjustment.toFixed(1)}% adjustment applied\n\n`, options: { fontSize: 20 } }
            ];

            slide.addText(findings, {
                x: 0.8, y: 1.5, w: 8.4, h: 2.5,
                valign: 'top'
            });

            slide.addText('Recommendation:', {
                x: 0.8, y: 4.2, w: 8.4, h: 0.4,
                fontSize: 18, bold: true, color: colors.secondary
            });

            slide.addText(recommendation, {
                x: 0.8, y: 4.6, w: 8.4, h: 0.7,
                fontSize: 16, color: colors.dark,
                italic: true
            });

            // Save the presentation
            pptx.writeFile({ fileName: 'Energy-Procurement-Analysis.pptx' });
        }
        
        // ========================================
        // Data Integration with Shared Store
        // ========================================
        
        // Configuration
        const DATA_CONFIG = {
            GITHUB_RAW_URL: 'https://raw.githubusercontent.com/ClemmensSES/SESSalesResources/main/data/lmp-database.json',
            STORAGE_KEY: 'secureEnergy_LMP_Data',
            FALLBACK_URLS: [
                'https://raw.githubusercontent.com/ClemmensSES/SESSalesResources/main/data/lmp-database.json',
                'data/lmp-database.json',
                '../data/lmp-database.json',
                './data/lmp-database.json'
            ]
        };
        
        // Data loading state
        let dataLoadAttempted = false;
        let dataSource = 'none';
        
        // Listen for data updates from parent portal
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'LMP_DATA_BROADCAST') {
                console.log('[LMP Portal] Received data broadcast');
                handleExternalDataUpdate(event.data);
            }
            
            // Handle analysis reload from Analysis History widget
            if (event.data && event.data.type === 'LOAD_ANALYSIS') {
                console.log('[LMP Portal] Loading analysis from history');
                loadSavedAnalysis(event.data.data);
            }
        });
        
        // Load a saved analysis into the form
        function loadSavedAnalysis(data) {
            if (!data) return;
            
            // Set client name
            const clientNameInput = document.getElementById('clientName');
            if (clientNameInput && data.clientName) {
                clientNameInput.value = data.clientName;
            }
            
            // Set ISO and wait for zones to populate
            const isoSelect = document.getElementById('iso');
            if (isoSelect && data.iso) {
                isoSelect.value = data.iso;
                populateZones(); // Refresh zones for this ISO
                
                // Set zone after zones are populated
                setTimeout(() => {
                    const zoneSelect = document.getElementById('zone');
                    if (zoneSelect && data.zone) {
                        zoneSelect.value = data.zone;
                    }
                }, 100);
            }
            
            // Set start date
            const startDateInput = document.getElementById('startDate');
            if (startDateInput && data.startDate) {
                startDateInput.value = data.startDate;
            }
            
            // Set term months
            const termMonthsInput = document.getElementById('termMonths');
            if (termMonthsInput && data.termMonths) {
                termMonthsInput.value = data.termMonths;
            }
            
            // Set fixed price
            const fixedPriceInput = document.getElementById('fixedPrice');
            if (fixedPriceInput && data.fixedPrice) {
                fixedPriceInput.value = data.fixedPrice;
            }
            
            // Set LMP adjustment if exists
            const lmpAdjustmentInput = document.getElementById('lmpAdjustment');
            if (lmpAdjustmentInput && data.lmpAdjustment !== undefined) {
                lmpAdjustmentInput.value = data.lmpAdjustment;
            }
            
            showNotification('Analysis parameters loaded - click Calculate to run', 'success');
        }
        
        // Handle external data updates
        function handleExternalDataUpdate(payload) {
            const { data, meta } = payload;
            
            if (!data) return;
            
            // Merge new data with existing ISO_DATA
            Object.keys(data).forEach(iso => {
                if (data[iso] && data[iso].length > 0) {
                    ISO_DATA[iso] = data[iso];
                    console.log(`[LMP Portal] Updated ${iso} with ${data[iso].length} records`);
                }
            });
            
            dataSource = 'broadcast';
            
            // Refresh ISO dropdown and UI
            buildZoneDataFromISO();
            updateISODropdown();
            populateZones();
            showNotification('Data updated!', 'success');
        }
        
        // Build zoneData object from loaded ISO_DATA
        function buildZoneDataFromISO() {
            Object.keys(ISO_DATA).forEach(iso => {
                if (ISO_DATA[iso] && ISO_DATA[iso].length > 0) {
                    const uniqueZones = {};
                    ISO_DATA[iso].forEach(record => {
                        const zoneValue = record.zone || record.zone_name || '';
                        const zoneLabel = record.zone_name || record.zone || '';
                        if (zoneValue && !uniqueZones[zoneValue]) {
                            uniqueZones[zoneValue] = zoneLabel;
                        }
                    });
                    
                    // Only update if we got zones from the data
                    if (Object.keys(uniqueZones).length > 0) {
                        zoneData[iso] = Object.keys(uniqueZones).sort().map(value => ({
                            value: value,
                            label: uniqueZones[value] || value
                        }));
                        console.log(`[LMP Portal] Built ${zoneData[iso].length} zones for ${iso}`);
                    }
                }
            });
        }
        
        // Update ISO dropdown based on available data
        function updateISODropdown() {
            const isoSelect = document.getElementById('iso');
            if (!isoSelect) return;
            
            const currentValue = isoSelect.value;
            
            // Get available ISOs from ISO_DATA
            const availableISOs = Object.keys(ISO_DATA).filter(iso => 
                ISO_DATA[iso] && ISO_DATA[iso].length > 0
            );
            
            if (availableISOs.length === 0) {
                // No data available - show placeholder
                isoSelect.innerHTML = '<option value="">-- No Data Available --</option>';
                showNoDataWarning();
                return;
            }
            
            // Clear and rebuild dropdown
            isoSelect.innerHTML = '';
            
            // ISO display names
            const isoNames = {
                'ISONE': 'ISO-NE',
                'PJM': 'PJM',
                'NYISO': 'NYISO',
                'MISO': 'MISO',
                'ERCOT': 'ERCOT',
                'CAISO': 'CAISO',
                'SPP': 'SPP'
            };
            
            availableISOs.sort().forEach(iso => {
                const option = document.createElement('option');
                option.value = iso;
                option.textContent = isoNames[iso] || iso;
                isoSelect.appendChild(option);
            });
            
            // Restore selection if still available, otherwise use first
            if (availableISOs.includes(currentValue)) {
                isoSelect.value = currentValue;
            } else {
                isoSelect.value = availableISOs[0];
            }
            
            // Update zones for selected ISO
            updateZoneOptions();
            
            // Hide no data warning if present
            hideNoDataWarning();
        }
        
        // Show warning when no data is available
        function showNoDataWarning() {
            if (document.getElementById('noDataWarning')) return;
            
            const warning = document.createElement('div');
            warning.id = 'noDataWarning';
            warning.style.cssText = `
                background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
                border: 3px solid #f59e0b;
                border-radius: 12px;
                padding: 20px;
                margin: 20px 0;
                text-align: center;
            `;
            warning.innerHTML = `
                <h3 style="color: #92400e; margin-bottom: 10px;">‚ö†Ô∏è No LMP Data Available</h3>
                <p style="color: #78350f; margin-bottom: 15px;">
                    Please load LMP data using one of the following methods:
                </p>
                <ul style="text-align: left; color: #78350f; margin: 0 auto; max-width: 400px; list-style-position: inside;">
                    <li>Use the <strong>LMP Data Manager</strong> to upload CSV data</li>
                    <li>Use the <strong>Arcadia Fetcher</strong> to fetch live data</li>
                    <li>Ensure <code>data/lmp-database.json</code> exists in your deployment</li>
                </ul>
                <button onclick="retryDataLoad()" style="
                    margin-top: 15px;
                    padding: 10px 20px;
                    background: #f59e0b;
                    color: white;
                    border: none;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: 600;
                ">üîÑ Retry Loading Data</button>
            `;
            
            const container = document.querySelector('.container');
            const firstCard = container?.querySelector('.card');
            if (firstCard) {
                firstCard.parentNode.insertBefore(warning, firstCard);
            }
        }
        
        // Hide no data warning
        function hideNoDataWarning() {
            const warning = document.getElementById('noDataWarning');
            if (warning) warning.remove();
        }
        
        // Retry loading data
        async function retryDataLoad() {
            showNotification('Retrying data load...', 'info');
            dataLoadAttempted = false;
            await initializeData();
        }
        
        // Show notification toast
        function showNotification(message, type = 'info') {
            const existingToast = document.querySelector('.toast-notification');
            if (existingToast) existingToast.remove();
            
            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : type === 'warning' ? '#f59e0b' : '#3b82f6'};
                color: white;
                border-radius: 8px;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 9999;
                animation: slideIn 0.3s ease-out;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // Convert records array to ISO_DATA format
        function convertRecordsToISOData(records) {
            const groupedData = {};
            
            records.forEach(record => {
                const iso = (record.iso || '').toUpperCase();
                if (!iso) return;
                
                if (!groupedData[iso]) {
                    groupedData[iso] = [];
                }
                
                groupedData[iso].push({
                    month: String(record.month).padStart(2, '0'),
                    year: String(record.year),
                    zone: record.zoneId || record.zone || '',
                    zone_name: record.zone || record.zoneId || '',
                    avg_da_lmp: parseFloat(record.lmp) || 0
                });
            });
            
            return groupedData;
        }
        
        // Load from GitHub JSON
        async function loadFromGitHub() {
            console.log('[LMP Portal] Attempting to load from GitHub JSON...');
            
            for (const url of DATA_CONFIG.FALLBACK_URLS) {
                try {
                    const response = await fetch(url + '?t=' + Date.now()); // Cache bust
                    if (!response.ok) continue;
                    
                    const jsonData = await response.json();
                    
                    if (jsonData && jsonData.records && jsonData.records.length > 0) {
                        const groupedData = convertRecordsToISOData(jsonData.records);
                        
                        Object.keys(groupedData).forEach(iso => {
                            if (groupedData[iso].length > 0) {
                                ISO_DATA[iso] = groupedData[iso];
                            }
                        });
                        
                        console.log(`[LMP Portal] Loaded ${jsonData.records.length} records from GitHub (${url})`);
                        dataSource = 'github';
                        return true;
                    }
                } catch (e) {
                    console.log(`[LMP Portal] Failed to load from ${url}:`, e.message);
                }
            }
            
            return false;
        }
        
        // Load from localStorage
        function loadFromStorage() {
            console.log('[LMP Portal] Attempting to load from localStorage...');
            
            try {
                const stored = localStorage.getItem(DATA_CONFIG.STORAGE_KEY);
                if (!stored) return false;
                
                const parsed = JSON.parse(stored);
                
                // Check for records array format
                if (parsed.records && Array.isArray(parsed.records) && parsed.records.length > 0) {
                    const groupedData = convertRecordsToISOData(parsed.records);
                    
                    Object.keys(groupedData).forEach(iso => {
                        if (groupedData[iso].length > 0) {
                            ISO_DATA[iso] = groupedData[iso];
                        }
                    });
                    
                    console.log(`[LMP Portal] Loaded ${parsed.records.length} records from localStorage`);
                    dataSource = 'localStorage';
                    return true;
                }
                
                // Check old format (data object with ISO arrays)
                if (parsed.data) {
                    Object.keys(parsed.data).forEach(iso => {
                        if (parsed.data[iso] && parsed.data[iso].length > 0) {
                            ISO_DATA[iso] = parsed.data[iso];
                        }
                    });
                    console.log('[LMP Portal] Loaded data from localStorage (old format)');
                    dataSource = 'localStorage';
                    return true;
                }
            } catch (e) {
                console.log('[LMP Portal] localStorage load failed:', e.message);
            }
            
            return false;
        }
        
        // Main data initialization function
        async function initializeData() {
            if (dataLoadAttempted) return;
            dataLoadAttempted = true;
            
            console.log('[LMP Portal] Initializing data...');
            
            // Try GitHub first (authoritative source)
            const githubLoaded = await loadFromGitHub();
            
            // Fall back to localStorage if GitHub fails
            if (!githubLoaded) {
                console.log('[LMP Portal] GitHub load failed, trying localStorage...');
                loadFromStorage();
            } else {
                // Cache GitHub data to localStorage for offline access
                try {
                    const cacheData = { records: [] };
                    Object.keys(ISO_DATA).forEach(iso => {
                        if (ISO_DATA[iso] && ISO_DATA[iso].length > 0) {
                            ISO_DATA[iso].forEach(item => {
                                cacheData.records.push({
                                    iso: iso,
                                    zone: item.zone_name,
                                    year: item.year,
                                    month: item.month,
                                    lmp: item.avg_da_lmp
                                });
                            });
                        }
                    });
                    localStorage.setItem(DATA_CONFIG.STORAGE_KEY, JSON.stringify(cacheData));
                    console.log('[LMP Portal] Cached GitHub data to localStorage');
                } catch (cacheErr) {
                    console.warn('[LMP Portal] Could not cache data:', cacheErr);
                }
            }
            
            // Check if we have any data
            const hasData = Object.keys(ISO_DATA).some(iso => ISO_DATA[iso] && ISO_DATA[iso].length > 0);
            
            if (hasData) {
                // Build zoneData from loaded ISO_DATA
                buildZoneDataFromISO();
                
                // Update UI
                updateISODropdown();
                
                // Count records
                let totalRecords = 0;
                let isoCount = 0;
                Object.keys(ISO_DATA).forEach(iso => {
                    if (ISO_DATA[iso] && ISO_DATA[iso].length > 0) {
                        totalRecords += ISO_DATA[iso].length;
                        isoCount++;
                    }
                });
                
                const sourceLabel = dataSource === 'github' ? 'GitHub Repository' : 
                                   dataSource === 'localStorage' ? 'Local Cache' : 'Unknown';
                showNotification(`Loaded ${totalRecords.toLocaleString()} records from ${isoCount} ISOs (${sourceLabel})`, 'success');
            } else {
                console.log('[LMP Portal] No data available from any source');
                showNoDataWarning();
            }
        }
        
        // Request data from parent on load (when embedded in portal)
        if (window.parent !== window) {
            setTimeout(() => {
                window.parent.postMessage({ type: 'REQUEST_LMP_DATA' }, '*');
            }, 500);
        }
        
        // Initialize data on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeData();
        });
        
        // Also initialize immediately if DOM is already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            initializeData();
        }
        
        // Add animation styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100px); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100px); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    </script>
    </div>
</body>
</html>
